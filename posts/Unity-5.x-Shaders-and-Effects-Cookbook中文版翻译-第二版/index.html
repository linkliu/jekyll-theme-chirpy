<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Unity 5.x shaders and effects cookbook中文版翻译（第二版）" /><meta name="author" content="Link Liu" /><meta property="og:locale" content="en_US" /><meta name="description" content="​ 我打算试着翻译这本技术书，目的又两个，1.希望自己能帮助英文不太好的朋友，2.希望自己也学到这些知识，顺便帮助自己提升英语水平。我英语水平不是很好，接下来如果有什么错误的地方，有看到的朋友还请帮忙纠正。我不会web前端技术，我想试着学学markdown语法，尽量让页面好看些但是最重要的还是内容。" /><meta property="og:description" content="​ 我打算试着翻译这本技术书，目的又两个，1.希望自己能帮助英文不太好的朋友，2.希望自己也学到这些知识，顺便帮助自己提升英语水平。我英语水平不是很好，接下来如果有什么错误的地方，有看到的朋友还请帮忙纠正。我不会web前端技术，我想试着学学markdown语法，尽量让页面好看些但是最重要的还是内容。" /><link rel="canonical" href="https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/" /><meta property="og:url" content="https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/" /><meta property="og:site_name" content="Game-Tech-Post" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-21T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Unity 5.x shaders and effects cookbook中文版翻译（第二版）" /><meta name="twitter:site" content="@mucylulu_renhai" /><meta name="twitter:creator" content="@Link Liu" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Link Liu"},"headline":"Unity 5.x shaders and effects cookbook中文版翻译（第二版）","dateModified":"2021-05-28T15:24:08+08:00","datePublished":"2021-05-21T00:00:00+08:00","description":"​ 我打算试着翻译这本技术书，目的又两个，1.希望自己能帮助英文不太好的朋友，2.希望自己也学到这些知识，顺便帮助自己提升英语水平。我英语水平不是很好，接下来如果有什么错误的地方，有看到的朋友还请帮忙纠正。我不会web前端技术，我想试着学学markdown语法，尽量让页面好看些但是最重要的还是内容。","url":"https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/","mainEntityOfPage":{"@type":"WebPage","@id":"https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Unity 5.x shaders and effects cookbook中文版翻译（第二版） | Game-Tech-Post</title><link rel="apple-touch-icon" sizes="180x180" href="/game-tech-post/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/game-tech-post/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/game-tech-post/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/game-tech-post/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/game-tech-post/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Game-Tech-Post"><meta name="application-name" content="Game-Tech-Post"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/game-tech-post/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/game-tech-post/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/game-tech-post/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/game-tech-post/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/game-tech-post/" alt="avatar" class="mx-auto"> <img src="https://linkliu.github.io/game-tech-post/assets/img/me.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/game-tech-post/">Game-Tech-Post</a></div><div class="site-subtitle font-italic">Focus on game develepment</div></div><ul class="w-100"><li class="nav-item"> <a href="/game-tech-post/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/game-tech-post/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/game-tech-post/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/game-tech-post/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/game-tech-post/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/linkliu" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/mucylulu_renhai" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['mucylulu','163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/game-tech-post/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/game-tech-post/"> Posts </a> </span> <span>Unity 5.x shaders and effects cookbook中文版翻译（第二版）</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Unity 5.x shaders and effects cookbook中文版翻译（第二版）</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Link Liu </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, May 21, 2021, 12:00 AM +0800" prep="on" > May 21 <i class="unloaded">2021-05-21T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, May 28, 2021, 3:24 PM +0800" prefix="Updated " > May 28 <i class="unloaded">2021-05-28T15:24:08+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="44877 words">249 min</span></div></div><div class="post-content"><p>​ 我打算试着翻译这本技术书，目的又两个，1.希望自己能帮助英文不太好的朋友，2.希望自己也学到这些知识，顺便帮助自己提升英语水平。我英语水平不是很好，接下来如果有什么错误的地方，有看到的朋友还请帮忙纠正。我不会web前端技术，我想试着学学markdown语法，尽量让页面好看些但是最重要的还是内容。</p><h2 id="unity-5x-shaders-and-effects-cookbook中文版第二版">Unity 5.x Shaders and Effects Cookbook中文版（第二版）</h2><h2 id="目录表">目录表</h2><h2 id="鸣谢"><a href="#credits">鸣谢</a></h2><h2 id="关于作者"><a href="#about_author">关于作者</a></h2><h2 id="wwwpacktpubcom"><a href="#packtpub">www.PacktPub.com</a></h2><ul><li><p><a href="#ebook">电子书, 优惠, 还有其他</a></p><li><p><a href="#subscribe">为什么需要订阅?</a></p></ul><h2 id="前言"><a href="#preface">前言</a></h2><ul><li><p><a href="#whatcover">这本书包含哪些内容</a></p><li><p><a href="#youneed">学习的过程中你需要准备的</a></p><li><p><a href="#who_for">本书的适合人群</a></p><li><p><a href="#sections">内容结构</a></p><ul><li><p><a href="#sections">始前准备</a></p><li><p><a href="#sections">操作步骤</a></p><li><p><a href="#sections">原理介绍</a></p><li><p><a href="#sections">额外内容</a></p><li><p><a href="#sections">相关补充</a></p></ul><li><p><a href="#Conventions">本书的一些文体说明</a></p><li><p><a href="#feedback">读者反馈</a></p><li><p><a href="#support">客户支持</a></p><ul><li><p><a href="#codedownload">示例代码下载</a></p><li><p><a href="#downloadPDF">本书一些彩图的下载</a></p><li><p><a href="#errata">勘误表</a></p><li><p><a href="#piracy">盗版声明</a></p><li><p><a href="#questions">本书有问题请联系</a></p></ul></ul><h2 id="1创建你的第一个着色器">1.<a href="#chapter1">创建你的第一个着色器</a></h2><ul><li><p><a href="#cha1_intro">介绍</a></p><li><a href="#CBSS">创建一个基本的标准着色器</a><ul><li><p><a href="#CBSS_getting_ready">始前准备</a></p><li><p><a href="#CBSS_how_to_do_it">操作步骤</a></p><li><p><a href="#CBSS_how_it_work">原理介绍</a></p><li><p><a href="#CBSS_see_also">额外内容</a></p></ul><li><a href="#MLSUU">如何把Unity 4的旧着色器迁移至Unity 5</a><ul><li><p><a href="#MLSUU_getting_ready">始前准备</a></p><li><a href="#MLSUU_how_to_do_it">操作步骤</a><ul><li><p>着色器版本的自动升级</p><li><p>使用标准着色器</p><li><p>迁移用户自定义的着色器</p></ul><li><p><a href="#MLSUU_how_it_works">原理介绍</a></p><li><a href="#MLSUU_see_also">额外内容</a></ul><li><a href="#APTS">给着色器添加属性</a><ul><li><p><a href="#APTS_getting_ready">始前准备</a></p><li><p><a href="#APTS_how_to_do_it">操作步骤</a></p><li><p><a href="#APTS_how_it_works">原理介绍</a></p><li><p><a href="#APTS_see_also">额外内容</a></p></ul><li><a href="#UPISS">使用表面着色器的属性</a><ul><li><p><a href="#UPISS_how_to_do_it">操作步骤</a></p><li><p><a href="#UPISS_how_it_works">原理介绍</a></p><li><p><a href="#UPISS_there_is_more">相关补充</a></p><li><p><a href="#UPISS_see_also">额外内容</a></p></ul></ul><h2 id="2表面着色器和纹理映射">2.<a href="#SSTM">表面着色器和纹理映射</a></h2><ul><li><p><a href="#SSTM_introduction">介绍</a></p><li><p><a href="#SSTM_diffuse_shading">漫反射的着色处理</a></p><ul><li><p><a href="#SSTM_getting_ready">始前准备</a></p><li><p><a href="#SSTM_how_to_do_it">操作步骤</a></p><li><p><a href="#SSTM_how_it_works">原理介绍</a></p></ul><li><a href="#UPA">使用包组</a><ul><li><a href="#UPA_how_to_do_it">操作步骤</a><ul><li>压缩矩阵</ul><li><a href="#UPA_see_also">额外内容</a></ul><li><a href="#ATTS">向着色器添加纹理</a><ul><li><p><a href="#ATTS_getting_ready">始前准备</a></p><li><p><a href="#ATTS_how_to_do_it">操作步骤</a></p><li><p><a href="#ATTS_how_it_works">原理介绍</a></p><li><p><a href="#ATTS_there_is_more">相关补充</a></p><li><p><a href="#ATTS_see_also">额外内容</a></p></ul><li><a href="#STBMUV">通过改变UV值来移动纹理</a><ul><li><p><a href="#STBMUV_getting_ready">始前准备</a></p><li><p><a href="#STBMUV_how_to_do_it">操作步骤</a></p><li><p><a href="#STBMUV_how_to_do_it">原理介绍</a></p></ul><li><a href="#NM">法线贴图</a><ul><li><p><a href="#NM_getting_ready">始前准备</a></p><li><p><a href="#NM_how_to_do_it">操作步骤</a></p><li><p><a href="#NM_how_it_works">原理介绍</a></p><li><p><a href="#NM_there_is_more">相关补充</a></p></ul><li><a href="#CATM">创建一个带透明度的材质</a><ul><li><p><a href="#CATM_getting_ready">始前准备</a></p><li><p><a href="#CATM_how_to_do_it">操作步骤</a></p><li><p><a href="#CATM_how_it_works">原理介绍</a></p></ul><li><a href="#CAHS">创建一个有全息效果的着色器</a><ul><li><p><a href="#CAHS_getting_ready">始前准备</a></p><li><p><a href="#CAHS_how_to_do_it">操作步骤</a></p><li><p><a href="#CAHS_how_it_works">原理介绍</a></p><li><p><a href="#CAHS_there_is_more">相关补充</a></p><li><p><a href="#CAHS_see_also">额外内容</a></p></ul><li><a href="#PABT">纹理的压缩和混合</a><ul><li><p><a href="#PABT_getting_ready">始前准备</a></p><li><p><a href="#PABT_how_to_do_it">操作步骤</a></p><li><p><a href="#PABT_how_it_works">原理介绍</a></p></ul><li><p><a href="#CCAYT">在地形的表面绘制一个圆</a></p><ul><li><p><a href="#CCAYT_getting_ready">始前准备</a></p><li><a href="#CCAYT_how_to_do_it">操作步骤</a><ul><li><a href="#CCAYT_move_the_circle">在表面移动这个圆</a></ul><li><a href="#CCAYT_how_it_works">原理介绍</a></ul></ul><h2 id="3-理解光照模型">3. <a href="#ULM">理解光照模型</a></h2><ul><li><p><a href="#ULM_introduction">介绍</a></p><li><p><a href="#CCDLM">创建一个自定义的漫反射光照模型</a></p><ul><li><p><a href="#CCDLM_getting_ready">始前准备</a></p><li><p><a href="#CCDLM_how_to_do_it">操作步骤</a></p><li><p><a href="#CCDLM_how_it_works">原理介绍</a></p></ul><li><p><a href="#CATS">创建一个Toon风格的着色器</a></p><ul><li><p><a href="#CATS_getting_ready">始前准备</a></p><li><p><a href="#CATS_how_to_do_it">操作步骤</a></p><li><p><a href="#CATS_how_it_works">原理介绍</a></p><li><p><a href="#CATS_there_is_more">相关补充</a></p></ul><li><p><a href="#CPST">创建一个Phong类型类型的高光反射着色器</a></p><ul><li><p><a href="#CPST_getting_ready">始前准备</a></p><li><p><a href="#CPST_how_to_do_it">操作步骤</a></p><li><p><a href="#CPST_how_it_works">原理介绍</a></p></ul><li><p><a href="#CBST">创建 BlinnPhong 类型的高光反射着色器</a></p><ul><li><p><a href="#CBST_getting_ready">始前准备</a></p><li><p><a href="#CBST_how_to_do_it">操作步骤</a></p><li><p><a href="#CBST_how_it_works">原理介绍</a></p><li><p><a href="#CBST_there_is_more">额外内容</a></p></ul><li><p><a href="#CAAST">创建各向异性类型的高光反射着色器</a></p><ul><li><p><a href="#CAAST_getting_ready">始前准备</a></p><li><p><a href="#CAAST_how_to_do_it">操作步骤</a></p><li><p><a href="#CAAST_how_it_works">原理介绍</a></p></ul></ul><h2 id="4unity-5中基于物理原理的渲染">4.<a href="#PBRIU5">Unity 5中基于物理原理的渲染</a></h2><ul><li><p><a href="#PBRIU5_introduction">介绍</a></p><li><p><a href="#UTMS">理解金属质感的设置</a></p><ul><li><p><a href="#UTMS_getting_ready">始前准备</a></p><li><p><a href="#UTMS_how_to_do_it">操作步骤</a></p><li><p><a href="#UTMS_how_it_works">原理介绍</a></p><li><p><a href="#UTMS_see_also">额外内容</a></p></ul><li><p><a href="#ATTOPBR">向PBR中添加透明度</a></p><ul><li><p><a href="#ATTOPBR_getting_ready">始前准备</a></p><li><p><a href="#ATTOPBR_how_to_do_it">操作步骤</a></p><ul><li><p>半透明材质</p><li><p>物体如何消失</p><li><p>如何在显示物体中挖一个孔</p></ul><li><p><a href="#ATTOPBR_see_also">额外内容</a></p></ul><li><p><a href="#CMARS">创建镜子和反射面</a></p><ul><li><p><a href="#CMARS_getting_ready">始前准备</a></p><li><p><a href="#CMARS_how_to_do_it">操作步骤</a></p><li><p><a href="#CMARS_how_it_works">原理介绍</a></p><li><p><a href="#CMARS_see_also">额外内容</a></p></ul><li><p>烘培场景中的光</p><ul><li><p>始前准备</p><li><p>操作步骤</p><ul><li><p>场景中静态几何体的设置</p><li><p>光探针的设置</p><li><p>光的烘培</p></ul><li><p>原理介绍</p><li><p>额外内容</p></ul></ul><h2 id="5顶点函数">5.顶点函数</h2><ul><li><p>介绍</p><li><p>在表面着色器中访问顶点颜色</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul><li><p>对表面着色器中的顶点使用动画</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul><li><p>模型的形变</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p><ul><li>添加形变纹理</ul></ul><li><p>实现一个被雪覆盖的着色器</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><ul><li><p>为物体表面设置颜色</p><li><p>修改几何体</p></ul><li><p>额外内容</p></ul><li><p>实现范围体爆炸</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p><li><p>额外内容</p></ul></ul><h2 id="6片元着色器和通道提取">6.片元着色器和通道提取</h2><ul><li><p>介绍</p><li><p>理解顶点和片元着色器</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p><ul><li><p>顶点的输入语义</p><li><p>顶点的输出语义</p></ul><li><p>额外内容</p></ul><li><p>使用通道提取</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul><li><p>实现一个玻璃效果的着色器</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul><li><p>在2D游戏中实现水效果的着色器</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul></ul><h2 id="7-移动设备中着色器的调整">7. 移动设备中着色器的调整</h2><ul><li><p>介绍</p><li><p>什么是着色器的轻量化?</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul><li><p>着色器的性能分析</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul><li><p>针对移动设备修改着色器</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul></ul><h2 id="8通过unity-渲染纹理实现屏幕特效">8.通过Unity 渲染纹理实现屏幕特效</h2><ul><li><p>介绍</p><li><p>设置屏幕特效脚本系统</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul><li><p>亮度, 饱和度和对比度在屏幕特效中的作用</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul><li><p>屏幕特效中基础的照片融合模式</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul><li><p>屏幕特效中的叠加混合模式</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul></ul><h2 id="9游戏和屏幕特效">9.游戏和屏幕特效</h2><ul><li><p>介绍</p><li><p>创建一个老电影屏幕特效</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>额外内容</p></ul><li><p>创建一个夜视仪效果的屏幕特效</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul></ul><h2 id="10更高级的着色器技术">10.更高级的着色器技术</h2><ul><li><p>介绍</p><li><p>使用Unity内建的CG包含文件功能</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul><li><p>CG包含文件功能如何让着色器模块化</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul><li><p>实现一个毛皮效果的着色器</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p><li><p>相关补充</p></ul><li><p>如何通过数组来实现热图</p><ul><li><p>始前准备</p><li><p>操作步骤</p><li><p>原理介绍</p></ul></ul><hr /><p><span id="credits"></span></p><p><strong>鸣谢</strong></p><p><strong>本书作者</strong></p><p>Alan Zucconi</p><p>Kenneth Lammers</p><p><strong>审稿</strong></p><p>Kenneth Lammers</p><p><strong>组稿编辑</strong></p><p>Priya Singh</p><p><strong>策划编辑</strong></p><p>Rahul Nair</p><p>Erol Staveley</p><p><strong>项目内容编辑</strong></p><p>Mehvash Fatima</p><p><strong>技术编辑</strong></p><p>Pranil Pathare</p><p>Danish Shaikh</p><p><strong>文字编辑</strong></p><p>Tasneem Fatehi</p><p><strong>项目助理</strong></p><p>Kinjal Bari</p><p><strong>校对员</strong></p><p>Safis Editing</p><p><strong>索引员</strong></p><p>Monica Ajmera Mehta</p><p><strong>图像</strong></p><p>Kirk D’Penha</p><p>Disha Haria</p><p><strong>制作协调员</strong></p><p>Nilesh Mohite</p><p><strong>封面设计</strong></p><p>Nilesh Mohite</p><hr /><p><span id="about_author"></span></p><p><strong>关于作者</strong></p><p><strong>Alan Zucconi</strong> 是一个充满激情的开发者, 作者, 和一个激励的演讲者, 是开发者领域的佼佼者。 有着过去10年来相关领域的专业技能积累，并且决定在今后把精力都放在学术领域和游戏产业领域。作为一名自由职业者，他以非凡的创造力去探索如何让游戏更好的与艺术结合。 在此之前，他在伦敦帝国理工学院工作，在这里他发现了他教学和写作的激情。 他的头衔包括了 gravity puzzle, 0RBITALIS, 和the upcoming time travel platformer, Still Time（这些单词实在不知道怎么翻译了，应该是游戏名字）.</p><p><strong>Kenneth Lammers</strong> 在游戏领域有超过15年的经验, 担任过角色艺术家，技术美术，技术美术总监，和程序员。这让他有机会参与《使命召唤3》《除暴战警2》 《心灵杀手》和《Kinect星球大战》等众多著名游戏的开发。他现在跟他的商业伙伴<strong>Noah Kaarbo</strong>一起运营自己的Ozone 工作。，同时，他们也跟亚马逊，Eline Media，IGT和微软也有过合作。他之前为微软游戏工作室，动视和Surreal工作过。现如今他离开了哪些工作室，一手开办了自己的 CreativeTD 和 Ozone 工作室（感觉翻译成互动娱乐更好）。Kenny通过Packt Publishing出版社写了他的第一版 《Unity Shaders and Effects Cookbook》书，整个过程非常的愉快。</p><hr /><p><span id="packtpub"></span></p><h2 id="wwwpacktpubcom-1"><a href="https://www.packtpub.com/">www.PacktPub.com</a></h2><p>这是一个电子书的网站，等于是帮这个网站宣传了吧，大家直接点击超链接进去看就行了。一般来说，你只要在上面买了电子书，特别是技术书籍，相关的代码，附件也可以从上面下载。</p><hr /><p><span id="ebook"></span></p><p><strong>电子书, 优惠折扣, 额外信息</strong></p><p>**Packt **电子书网站拥有包含pdf和ePub格式的所有已经出版的书籍的电子书。你可以在www.PacktPub.com 更新你的电子书版本并且如果你购买过相应的纸质书籍的话，可以在购买对应的电子版本时享有折扣。你可以通过 <a href="mailto:customercare@packtpub.com">customercare@packtpub.com</a> 这个邮箱向我们了解优惠的详细信息。你可以在 www.PacktPub.com 阅读一系列免费的技术文章，现在在网站注册可以获知最新的免费和折扣信息</p><p><a href="https://www2.packtpub.com/books/subscription/packtlib">https://www2.packtpub.com/books/subscription/packtlib </a></p><p>（告诉大家一个不幸的消息，上面这个网址已经过期了）</p><p>你是否因为IT技术问题缺乏具体的示例而苦恼，上面这个网站也许可以帮到你，这是一个在线的数字图书馆。你可以在这个数字图书馆上搜索，获取资料和阅读<strong>Packt</strong>电子书网站为你准备的丰富的电子书。</p><hr /><p><span id="subscribe"></span></p><p><strong>为什么希望你订阅?</strong></p><p>可以查阅所有 <strong>Packt</strong>网站发布的的书籍</p><p>可以拷贝，打印所有书籍</p><p>可以通过浏览器查找你最需要的资料</p><hr /><p><span id="preface"></span></p><h2 id="前言-1">前言</h2><p><strong>Unity 5.x Shaders and Effects Cookbook</strong>这本书能让你在Unity5引擎中创建着色器和特效更加得心应手，能让你入门起来比较容易，学会创建大部分基础的着色器，并且学会如何组织你的着色器代码。本书的章节安排是循序渐进的，每一章节的基础知识，旨在后面让你能实现更高级的技术技巧，比如实现范围体爆炸效果，毛皮特效等。这本书是专门在Unity5这个游戏引擎下讲解的，希望帮助你掌握诸如基于物理原理的渲染和全局光照等知识，让你尽可能获得照片级的效果。</p><p>在每一章的结尾，你都会获得一些新的技巧，这些技巧有助于提高你的着色器质量并且让你在写着色器的时候更加有效率。 为了让你能从入门到专家，每一个章节的特殊技巧和知识点都是我们为你精心编排的。对于着色器的初学者来说，你也可以通过一个章节一个章节的阅读，逐渐丰富你的着色器知识。不管怎样，通过本书的知识点，可以让你的游戏在次世代看起来更棒。当你完成这本书的学习之后，在Unity3d创建游戏的过程中，你就可以有各种各样的着色器用于你的游戏，并且了解怎么向你的游戏中去添加它们，怎么向你的游戏添加各种特效，怎么去优化你的游戏。让我们开始吧。</p><hr /><p><span id="whatcover"></span></p><p><strong>这本书包含哪些内容</strong></p><p><strong><u>第一章</u></strong>,创建你的第一个着色器, 向你介绍如何在unity4和unity5中编写着色器代码（我会试着在unity2018上去实验，保证shader代码的正常执行，不限于unity4和5）。</p><p><strong><u>第二章</u></strong>, 表面着色器和贴图映射, 介绍了一些如何实现表面着色器的通用且实用的技术，比如如何给游戏模型使用纹理和法线贴图。</p><p><strong><u>第三章</u></strong>, 理解光照模型，带你深入理解在给模型使用着色器时光带来的影响，这一章会教你一些如何实现自定义的光照模型的技术技巧，以便于你去实现一些独特的特效，比如Toon着色器效果。</p><p><strong><u>第四章</u></strong>, Unity 5中基于物理原理的渲染, 这一章为你介绍在unity5中基于物理原理的标准渲染技术，这些技术主要是为了在你的游戏中实现次世代的画面（直译就是看起来跟现实世界一样）。会向你解释如何尽可能的模拟这种现实，让你对透明度，反射表面和全局光照有更深入的理解。</p><p><strong><u>第五章</u></strong>, 顶点函数,向你介绍如何使用着色器来修改游戏中物体的几何特性；想知道范围体爆炸，着色器模拟下雪等特效嘛？这一章里的着色器操作顶点的技术技巧会告诉你如何实现</p><p><strong><u>第六章</u></strong>, 片元着色器和通道提取, 这一章会解释如何使用半透明材质和通道提取来实现扭曲形变效果</p><p><strong><u>第七章</u></strong>, 移动设备中着色器的调整，主要介绍如何针对移动设备进行优化。</p><p><strong><u>第八章</u></strong>, 通过Unity 渲染纹理实现屏幕特效,介绍了通过该技术才能更容易实现的视觉特效的实现方式。</p><p><strong><u>第九章</u></strong>, 游戏和屏幕特效,向你介绍一些游戏后处理特效，让游戏模拟的更加真实，比如夜视仪特效。</p><p><strong><u>第十章</u></strong>, 更高级的着色器技术,介绍一些向毛坯特效的着色器，热图渲染等本书会涉及的大部分高级技术技巧</p><hr /><p><span id="youneed"></span></p><p><strong>学习的过程中你需要准备的</strong> 下面列举了在学习本书知识的过程中必须的工具软件和可选的工具软件:</p><ul><li>Unity5引擎<li>一款3D建模软件，比如Maya，3DMax，或Blender (可选l)<li>一款2D图片编辑软件，比如PS或者Gimp (可选)</ul><hr /><p><span id="who_for"></span></p><p><strong>本书的适合人群</strong></p><p>本书适合色器编程初学者，或者想通过专业的后处理特效让游戏更棒的开发者。</p><p>当然开发者本身需要对Unity游戏引擎有比较深入的理解。</p><hr /><p><span id="sections"></span></p><p><strong>内容结构</strong></p><p>在本书中， 会经常出现一系列的小标题 (<strong>始前准备</strong>，<strong>操作步骤</strong>，<strong>原理介绍</strong>，<strong>额外内容</strong> ，<strong>相关补充</strong>)。</p><p>主要功能是对每一个知识点进行说明，如何完成该知识点的掌握。下面说明具体的用法：</p><ul><li><p><strong>始前准备</strong></p><p>这个部分会告诉你这个知识点会学习什么，怎么安装和设置对应的软件。</p><li><p><strong>操作步骤</strong></p><p>这个部分包含了学习该知识点包含那些步骤。</p><li><p><strong>原理介绍</strong></p><p>该部分通常是为了详细解释“<strong>操作步骤</strong>”这个部分的知识原理，上面的每一步到底做了什么。</p><li><p><strong>额外内容</strong></p><p>为了让读者了解更多与该知识点相关的额外知识，我们才准备了这个额外信息让读者阅读。</p><li><p><strong>相关补充</strong></p><p>如果想了解更多与该知识点相关的信息，这里还额外提供了一些相关链接。</p></ul><hr /><p><span id="Conventions"></span></p><p><strong>本书的一些文体说明</strong></p><p>在书中你可以发现很多种不同的文本样式用来表示不同的信息内容。这里列举几个来解释一下。（需要说明一下的是，我在翻译的过程中，代码的字体样式可能会跟书本上不一样，我主要是用markdown的代码块来表示。然后它的粗体，比如强调，那我就用markdown中的强调标签来表示，说声抱歉了，希望大家能看的懂）</p><p>代码块，数据库表名，文件夹名字 ，文件名字，文件扩展名，路径名称，虚拟URL（觉得这个翻译不准确），用户输入，推特账号等会按照如下表示：“请输入下面的代码到你的着色器属性块（**Properties **）中”</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span> 
<span class="p">{</span> 
	<span class="n">float4</span> <span class="n">c</span><span class="p">;</span> 
	<span class="n">c</span> <span class="p">=</span> <span class="nf">pow</span><span class="p">((</span><span class="n">_EmissiveColor</span> <span class="p">+</span> <span class="n">_AmbientColor</span><span class="p">),</span> <span class="n">_MySliderValue</span><span class="p">);</span> 
	<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span> <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>  
</pre></table></code></div></div><p>当我们想提醒你代码块中的特别部分，那么对应的代码行或者语句会用粗体标记,比如那个void：(代码块中我不知道怎么加粗，下面这个就不用代码块了)</p><p><strong>void</strong> surf (Input IN, inout SurfaceOutputStandard o)</p><p>{</p><p>​ fixed4 c = pow((_Color + _AmbientColor), _MySliderValue);</p><p>​ o.Albedo = c.rgb;</p><p>​ o.Metallic = _Metallic;</p><p>​ o.Smoothness = _Glossiness;</p><p>​ o.Alpha = c.a;</p><p>}</p><p><strong>新的术语</strong> 和 <strong>非常重要的词语</strong> 都应该用粗体表示.像出现再电脑屏幕中的菜单和弹窗中的文本，也会用粗体加以强调。比如：“在Unity编辑器的菜单栏中的“<strong>项目(Project)</strong>,在<strong>资产(Assets)</strong>文件夹上右键单击和在菜单中选择<strong>创建(Create)|文件夹(Folder)</strong>。” （中文后面括号里的是英文版的编辑器中菜单项的名字）</p><p><strong>注意(Note)</strong></p><p>警告或者很重要的注意会像这样，有个<strong>注意(Note)</strong>提醒你。</p><p><strong>提示(Tip)</strong></p><p>提示和小技巧会像这样，有个<strong>提示(Tip)</strong>提示你。</p><hr /><p><span id="feedback"></span></p><p><strong>读者反馈</strong></p><p>非常欢迎来自各位读者的反馈。这能让我们知道你们是否喜欢这本书。你们给与的重要反馈可以让我们写出更适合且对你们更有帮助的内容。</p><p>通常最简单的反馈方式是通过<a href="mailto:feedback@packtpub.com">feedback@packtpub.com</a>邮箱给我们发邮件，然后在反馈邮件的标题中告诉我们书标题。</p><p>如果在本书中有你擅长领域的话题想跟我们讨论，或者你愿意把你专长领域的知识贡献给本书，也可以通过这个网址 <a href="https://www.packtpub.com/authors">www.packtpub.com/authors</a>的指引进行操作</p><hr /><p><span id="support"></span></p><p><strong>客户支持</strong></p><p>很高心您能拥有此书，为了让您物有所值，我们还为你准备了很多东西（很搞不懂这也要搞一个章节出来，就一句话）。</p><hr /><p><span id="codedownload"></span></p><p><strong>示例代码下载</strong></p><p>通过这个网站<a href="https://www.packtpub.com/">http://www.packtpub.com</a>，你可以用自己的账号下载本书的实例代码(其实我本人是建议自己手动敲一遍，我试了一下，代码是可以直接在这个网站下载的，就算你没有购买这本书也是可以的。但是需要注册一个账号才行，然后搜索到这本书，这本书的页面下面就有下载代码的链接)。如果你在别的地方购买了这本书，那么你可以浏览网站<a href="https://www.packtpub.com/support"> http://www.packtpub.com/support</a>注册一个账号，然后在该页面直接通过书名搜索，也能找到这些文件的下载链接。</p><p>代码文件可以通过下面的步骤获得：</p><ol><li><p>通过邮箱和账号密码在我们的<a href="https://www.packtpub.com/">网站</a>上登陆或者注册。</p><li><p>把网页拉到最下面，点击<strong>支持主页(<a href="https://www.packtpub.com/support">Support Home</a>)</strong>（这本书出了很久了，网页早就改版了，这是我实际打开网页的操作步骤）。</p><li><p>然后点击该页面左边的<strong>代码下载&amp;勘误表(Code Downloads &amp; Errata)</strong>。</p><li><p>然后在<strong>搜索(Search)</strong>框中输入你的书名（不用输入完整的书名，支持模糊搜索）。</p><li><p>选择那本你想要下载代码的书。</p><li><p>然后在下面的下拉菜单中选择你是从哪儿购买本书的（不要紧，随便选一个，然后下拉菜单的下面就会有一个下载链接）。</p><li><p>然后点击<strong>代码下载</strong>（链接早就生成了，为了方便大家，我贴出链接，点击就可以<a href="https://account.packtpub.com/getfile/9781785285240/code">下载</a>了，不清楚是否是永久链接）</p></ol><p>下载好后，请自行解压，然后就可以获得本书的代码了。</p><hr /><p><span id="downloadPDF"></span></p><p><strong>本书一些彩图的下载</strong></p><p>这本书中的彩图，比如说屏幕截图/示意图我们都把他放在了一个PDF文件中。希望这些图片可以让你更好的理解屏幕输出图像的变化。 你可以通过下面的链接下载这个PDF文件<a href="https://static.packt-cdn.com/downloads/Unity5xShadersAndEffectsCookbook_SecondEdition_Graphics.pdf">https://www.packtpub.com/sites/default/files/downloads/Unity5xShadersAndEffectsCookboo</a></p><hr /><p><span id="errata"></span></p><p><strong>勘误表</strong></p><p>尽管我们非常注意本书内容的准确性，但还是会有不小心出错的地方。如果您在我们出版的书中（不限本书）找到了错误，有可能是文字错误或者代码错误，我们非常欢迎您将这些错误报告给我们。如此善举，既解他人之惑，亦可助改善此书。如果您发现任何勘误，请通过链接<a href="https://www.packtpub.com/support/errata">https://www.packtpub.com/support/errata</a> （原书写的链接失效了）向我们报告。当您的勘误确认后，您提交的勘误将会被接受并且勘误会上传至我们的网站和任何已存在的勘误名单中。 如果您想看看之前的勘误提交，可以访问<a href="https://www.packtpub.com/support/code-downloads">https://www.packtpub.com/support/code-downloads</a>（原书的网址失效了，现在是这个），然后输入书名搜索，你想要的信息会出现在下面的勘误部分。</p><hr /><p><span id="piracy"></span></p><p><strong>盗版声明</strong></p><p>在网上，所有媒体的版权资料盗版问题从未停歇。 在<strong>Packt</strong>网，我们非常重视保护我们的版权和许可证。如果你在英特网上看到任何来自我们工作成果的 非法拷贝，不管来自那里，还请你提供给我们地址或者网址，这样我们可以挽回我们的损失。还请通过<a href="mailto:copyright@packtpub.com">copyright@packtpub.com</a>邮箱联系我们。</p><p>我们非常感激您帮助我们保护作者和保护我们继续给你带来有价值的内容。</p><hr /><p><span id="questions"></span></p><p><strong>本书有问题请联系</strong></p><p>如果您对本书有任何层面的问题，您可以通过邮箱<a href="mailto:questions@packtpub.com">questions@packtpub.com</a>联系我们，我们会尽己所能改善这些问题。</p><hr /><p><span id="chapter1"></span></p><h2 id="第一章-创建你的第一个着色器">第一章 创建你的第一个着色器</h2><p>在这一章我们包含了一些在当今<strong>游戏开发着色器管线</strong>中更通用的漫反射技术基础。在这一章我们将会学习下面的知识点:</p><ul><li>创建一个基础的标准着色器<li>从Unity4迁移旧着色器至Unity5<li>为着色器添加属性<li>在表面着色器中使用属性</ul><p><span id="cha1_intro"></span></p><h3 id="介绍">介绍</h3><p>让我在脑海中想象一个完全由白色绘制立方体。尽管立方体的每一个面的颜色都是相同的，但是由于不同方向的光线照射和我们看这个立方体的角度的不同，我们总能发现立方体不同的白色阴影。这种层级的逼真场景就是通过3D图形学中的着色器实现的，它是一种模拟光的作用原理的特别的程序。一个木质的立方体和一个金属的立方体也许可以是同一种3d模型，之所以让他们看起来一个是木质的，一个是金属的，就是因为它们使用了不同的着色器的缘故。我们循序渐进，第一章将会向你介绍如何在Unity中进行着色器编码。如果你从来没有编写着色器的经验，那么在这一章，你将会了解着色器是什么，他们如何工作和如何自定义着色器。 接着在这一章的结尾，你将会学习如何构建拥有基础操作的基础着色器。有了这些知识后，那么你将可以创建任何的表面着色器。</p><p><span id="CBSS"></span></p><h3 id="创建一个基本的标准着色器">创建一个基本的标准着色器</h3><p>每一个Unity游戏开发者应该都对<strong>组件(components)</strong>这个概念非常熟悉。游戏中的对象都有很多的组件，这些组件决定了游戏中的对象看起来是什么样子和会有什么样的行为。然而<strong>游戏脚本(scripts )</strong> 定义的是游戏对象会有怎样的行为，<strong>渲染器(renderers )</strong>决定游戏对象如何出现在屏幕中。 对于我们想要看到游戏对象类型，Unity本身提供了一些渲染器。每一个3D模型通常都有一个网格渲染器。一个游戏对象应该只能有一个渲染器，但是一个渲染器它可以包含多个<strong>材质(materials)</strong>。 每个材质封装了一个着色器–3D图形的最后一环。这些组件的关系可以用如下的示意图表示：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram1.png" /></div><center>理解这些组件之间的不同之处对于理解着色器的工作原理是很有必要的</center><hr /><p><span id="CBSS_getting_ready"></span></p><ul><li><strong>始前准备</strong> 开始学习这个知识点之前，你需要打开你的Unity5并且创建一个新的项目。本书的内容讲解都会在这个项目中开展，随着学习的深入你之后自己创建的着色器都可以放在这。这一步完成之后—-欢迎来到着色器实时编程的精彩世界。</ul><hr /><p><span id="CBSS_how_to_do_it"></span></p><ul><li><p><strong>操作步骤</strong></p><p>在创建我们的第一个着色器前，让我们为实验着色器创建一个简单游戏场景。首先我们导航到Unity的菜单栏，然后选择<strong>游戏对象|创建空对象</strong>。然后在Unity编辑器的<strong>层级面板(Hierarchy)</strong>选中刚刚创建的空对象，在上面创建一个平面作为地面，再创建几个球体用来应用我们的着色器，然后在场景里面创建平行光源。当场景弄好后，我们接下来就按步骤开始着色器的编写：</p><ol><li><p>在编辑器的<strong>项目(Project)</strong>窗口中，直接右键选择<strong>创建(Create)|文件夹(Folder)</strong>。【这里的文件夹名字我就直接用英文了，大家在自己开发的过程中也尽量用有意义的英文文件夹吧】 <strong>注意</strong> 如果你导入了本书提供的项目文件（就是你从网站上下载的代码，他是一个unitypackage包，导入之后这个文件自动就有了），你可以直接跳至步骤4。</p><li><p>选择该文件夹，右键然后选择<strong>重命名(Rename)</strong>，把这个文件夹命名成<strong>Shaders</strong>。或者你也可以选中该文件夹，然后按<strong>F2</strong>，重命名为<strong>Shaders</strong>。</p><li><p>用上面同样的方法创建一个<strong>Materials</strong>的文件夹，用来放材质文件的。</p><li><p>右键<strong>Shaders</strong>文件夹，然后在出的窗口中选择<strong>创建(Create)|着色器(Shader)|标准表面着色器(Standard Surface Shader)</strong>（这里注意跟原文不一样，创建一个着色器要三步，书中只有两部）。接着我们创建一个材质，右键<strong>Materials</strong>文件夹，然后在弹窗中选择<strong>创建(Create)|材质(Material)</strong>。</p><li><p>把刚刚创建的着色器和材质都命名成<strong>StandardDiffuse</strong>。【各位，文件名也用英文呀，因为怕Unity对中文的支持不好】</p><li><p>然后用Visual Studio 2015或者Visual Studio Code打开<strong>StandardDiffuse</strong>这个着色器【这里我不建议用MonoDevelop这个编辑器，原文是用这个，不好用，强烈建议用各位用Visual Studio Code打开，这个编辑器很好用，一定要去试试】 <br /> <strong>注意</strong><br /> 打开着色器你会发现Unity其实已经为我们的着色器生成了一些基本的代码。这些基础代码给了你一个基础的漫反射着色器，而且可以传入一张纹理。我们会在后面的步骤修改这些着色器代码，创建自己的着色器。</p><li>首先我们给自己的着色器一个自定义的文件夹【这不是传统的文件夹，我更倾向理解为材质选择路径】，这样方便使用时可以按照这个文件夹找到它。着色器的第一行代码是一段描述，这段描述的作用是当我们为材质选择着色器时，这段描述会会转换成选择路径，给材质添加我们自己的着色器。我们把这个路径重写为 <strong>Shader “CookbookShaders/StandardDiffuse”</strong>。当然你也能在任何时间把它命名为任何路径。不用特别在意这个路径名。然后记得保存我们的代码，然后切换回Unity编辑器。当Unity编辑器检测到着色器代码有更新，它会自动重新编译着色器。修改后的着色器代码如下所示：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>  <span class="n">Shader</span> <span class="s">"CookbookShaders/StandardDiffuse"</span> <span class="p">{</span>
   <span class="n">Properties</span> <span class="p">{</span>
       <span class="nf">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
       <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Albedo (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
       <span class="nf">_Glossiness</span> <span class="p">(</span><span class="s">"Smoothness"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
       <span class="nf">_Metallic</span> <span class="p">(</span><span class="s">"Metallic"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.0</span>
       <span class="p">}</span>
       <span class="n">SubShader</span> <span class="p">{</span>
           <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
           <span class="n">LOD</span> <span class="m">200</span>
           <span class="n">CGPROGRAM</span>
           <span class="c1">// Physically based Standard lighting model, and enable shadows on all light types</span>
           <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Standard</span> <span class="n">fullforwardshadows</span>
           <span class="c1">// Use shader model 3.0 target, to get nicer looking lighting</span>
           <span class="err">#</span><span class="n">pragma</span> <span class="n">target</span> <span class="m">3.0</span>
           <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
           <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
               <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
               <span class="p">};</span>
           <span class="n">half</span> <span class="n">_Glossiness</span><span class="p">;</span>
           <span class="n">half</span> <span class="n">_Metallic</span><span class="p">;</span>
           <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>
           <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
               <span class="c1">// Albedo comes from a texture tinted by color</span>
               <span class="n">fixed4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="p">*</span> <span class="n">_Color</span><span class="p">;</span>
               <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
               <span class="c1">// Metallic and smoothness come from slider variables</span>
               <span class="n">o</span><span class="p">.</span><span class="n">Metallic</span> <span class="p">=</span> <span class="n">_Metallic</span><span class="p">;</span>
               <span class="n">o</span><span class="p">.</span><span class="n">Smoothness</span> <span class="p">=</span> <span class="n">_Glossiness</span><span class="p">;</span>
               <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
           <span class="p">}</span>
           <span class="n">ENDCG</span>
       <span class="p">}</span><span class="n">FallBack</span> <span class="s">"Diffuse"</span>
  <span class="p">}</span>
</pre></table></code></div></div><li>专业一点说，这是一个<strong>基于物理原理渲染(physically-basedrendering)</strong>的表面着色器，只是Unity5把它作为了一个内建的标准着色器。根据这种着色器的字面意思，这是一种根据现实中光的物理原理，来模拟游戏中光照射到物体时所表现的物理特性，通过这种模拟，来虚拟现实。 如果你用的时早期版本的着色器（比如Unity4），那么你的着色器代码跟现在的会有比较大的差别。相比于现在的基于物理原理的着色器技术而言，Unity4使用的技术还是相对比较简单的。所有的这些着色器类型我们会在本书后面的章节介绍。<li><p>当你的着色器创建好后，我们需要将它与材质关联起来。选中我们之前在步骤4创建的<strong>StandardDiffuse</strong>材质，然后看<strong>检查器面板(Inspector tab)</strong>。然后再<strong>着色器(Shader)</strong>下拉列表中选择<strong>CookbookShaders | StandardDiffuse</strong>。（如果你在第7步修改的路径跟书上不一样，那么这里的选项也不一样）通过上述步骤，你的着色器就会跟这个材质关联起来，你现在可以把这个材质添加到一个游戏对象中去了。 <strong>注意</strong></p><p>你可以在<strong>项目窗口(Project tab)</strong>选中这个材质，然后直接拖拽到你在游戏场景中的游戏对象身上。当然你也可以直接选中这个材质，然后拖拽到Unity编辑器的<strong>检查器面板(Inspector tab)</strong>上，把这个材质应用到这个游戏对象上，前提是你要先选中这个游戏对象，然后再拖拽，这样<strong>检查器面板(Inspector tab)</strong>显示的才是游戏对象的属性。</p><p>下面时这个示例的屏幕截图：【各位按照自己的情况来就行了，不一定非要找一个跟书本一样的模型】</p></ol></ul><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram2.png" /></div><center>看起来很简陋, 但是着色器开发环境搭建好了，接下来我们可以开发自己想要的着色器了</center><hr /><p><span id="CBSS_how_it_work"></span></p><ul><li><p><strong>原理介绍</strong></p><p>Unity帮助你简化了着色器运行的环境配置，你很多时候只需要点击鼠标就可以完成。但事实上这些简单的操作背后有着大量的各种各样的工作，只是Unity引擎替你做了。Unity 使用CG着色器语言，并且它在背后做了大量的工作【unity会自动生成相应的CG代码】，让你在写着色器的时候非常高效。用表面着色器格式的语言来写着色器更加方便。比如处理你自己的纹理的坐标或者线性变换矩阵，这些功能都已经准备好，不用再从头开始。以前写着色器，你必须重新创建一个着色器然后一遍又一遍的重新很多代码。随着你对表面着色器的深入理解，你可能会越想了解CG语言更底层的功能以及Unity是如何处理那些更底层的<strong>图形处理单元(graphics processing unit (GPU))</strong>任务的。</p><p><strong>注意</strong> Unity项目中的所有文件都有自己的引用，跟它在你电脑上具体的某个文件夹上没有关系。我们在编辑器上，你可以可以随便移动着色器文件和材质文件，它们之间不会有关联信息丢失的风险。但你千万不要在编辑器外面移动这些文件，【比如直接打开项目文件夹，在电脑上直接移动这些文件】这样的话Unity编辑器不能够更新这些文件之间的关联，可能会发生丢失的情况。</p><p>我们通过简单的修改着色器的路径属性可以给着色器一个我们想要的名字，我们在Unity环境中进行了基础的漫反射着色器的研究，包括光呀，阴影呀之类的。而这些，仅仅是通过改变一行代码。</p></ul><hr /><p><span id="CBSS_see_also"></span></p><ul><li><p><strong>额外内容</strong></p><p>在Unity5中内建的着色器的源码通常被隐藏起来了，你不能像打开自己的着色器代码那样打开它。在你的Unity安装目录<strong>Unity45\Editor\Data\CGIncludes</strong>，你能找到大部分的Unity内建的CG功能代码。在这个目录下面，你能找到被Unity隐藏起来的一些着色器。 经过多年的迭代，它们已经发生了很多的改变；如果你想查阅Unity不同版本之间的色器源码发生了那些变化，下面这个网站也许是个好去处：<a href="https://unity3d.com/get-unity/download/archive">https://unity3d.com/get-unity/download/archive</a>。选择你的Unity版本，然后在下拉列表中选择<strong>内建着色器(Built in shaders)</strong> ，如下图所示。 此时我们需要留意其中的三个文件—<strong>UnityCG.cginc</strong>，<strong>Lighting.cginc</strong>和<strong>UnityShaderVariables.cginc</strong>。我们现在学习的着色器都只要用到这三个相关的文件：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram3.png" /></div><center>第十章.<i><b>更高级的着色器技术</b></i>, 我们将会深层次探索如何使用GcInclude进行模块化的着色器编程</center></ul><hr /><p><span id="MLSUU"></span></p><h3 id="如何把unity-4的旧着色器迁移至unity-5">如何把Unity 4的旧着色器迁移至Unity 5</h3><p>不可否认，在过去10年中图形学在电子游戏中获得了惊人的发展。每一个新游戏带来的尖端技术让我们的游戏画面更加接近现实。随着Unity引擎版本的不断迭代，它的着色器技术也自然而然的经历了相当大的变化。这也是为什第一次接触着色器的时候感到困惑的原因。在Unity5还没有推出之前，Unity自带了两种不同的着色器，分别是：<strong>漫反射(Diffuse)</strong>和<strong>镜面反射(Specular)</strong>。正如其名字所描述，它们分别用来模拟表面粗糙和表面光滑的材料。如果你现在使用的Unity5，那么你其实可以跳过这个知识点。该知识点会讲解如何在Unity5中重现这些效果。</p><hr /><ul><li><p><strong>始前准备</strong><span id="MLSUU_getting_ready"></span></p><p>要开始这个知识点，前提时你有个用Unity4版本作为开发引擎工作空间，并且你使用了这个版本内建的一些着色器。当你开发新游戏的时候，毫无疑问你应该改选择最新版本的Unity引擎。然而如果你的项目已经使用了旧版的Unity引擎开发，那么你在迁移着色器前应该三思。引擎背后可能又很多东西都不一样了，即使有时候内建的着色器表面看起来可以正常工作，但是你写的脚本可未必能。所以如果你要迁移整个项目空间，这个时候首先要做的事情就是备份。但是要注意噢，仅仅只是保存Assets资源和场景可不够，同时所有的.meta文件也要一并保存，因为大多数Unity的配置信息保存在元数据中。在迁移项目的过程中最稳妥的办法还是要把整个项目空间所在文件夹都复制一份。最好的是物理拷贝一份，如果是windows就在资源管理器物理复制，如果是Mac就在Finder中物理复制。【建议大家将这个项目目录用压缩工具【如winrar】打包一份】。 ***</p><li><p><strong>操作步骤</strong><span id="MLSUU_how_to_do_it"></span></p><p>如果你想要迁移你的内建着色器，有两个主要选择：采用自动升级的方式或者切换至<strong>标准着色器</strong></p><ul><li><p><strong>着色器版本的自动升级</strong></p><p>这种选择是最操作起来最简单的。Unity5可以导入使用旧版内建着色器的项目并且自动升级。你需要主义的是一旦升级完成后，那么你在Unity4中就不能再使用它们了。尽管这个过程并没有直接改变你的Assets资源，但是Unity的元数据已经被转换过了。要进行这个过程，你需要打开Unity5引擎，然后点击<strong>文件(File)|打开项目(Open Project)</strong>来打开你就项目所在的文件夹。然后回有提示问你是否愿意转换；然后点击<strong>升级(Upgrade)</strong>执行改过程。Unity就会重新导入所有的Assets资源并且重新编译所有的游戏脚本。如果你的项目非常巨大，这个过程可能回持续几个小时。一旦转换完成，来自Unity4的内建的旧着色器会被相应的替换掉。 你可以通过检查器面板验证这个转换，材质实例中从原来的<strong>Bumped Diffuse</strong>变为了<strong>Legacy Shader/Bumped Diffuse</strong>。</p><p><strong>注意</strong></p><p>尽管Unity4版本的漫反射，镜面反射和其他内建的着色器现在已经已弃用了，但是Unity5依然向后对它们保持兼容。它们在材质的<strong>Legacy Shaders</strong>路径下的下拉列表中依然可以看到。</p><li><p><strong>使用标准着色器</strong></p><p>相比于使用旧版本的着色器，你可能想使用Unity5新的内建标准着色器替代它们。但是这么做之前，请留意新旧两个版本的着色器是基于不同的光照模型的，你的材质很可能看起来不一样。Unity4总共有8个不同的内建着色器，它被划分进了6个大类(<strong>法线(Normal)</strong>，<strong>透明(Transparent)</strong>，<strong>透明剪切(Transparent Cutout)</strong>，<strong>自发光(Self-Illuminated)</strong>和<strong>反射(Reflective)</strong>)。但在Unity5中，它们都被上一个知识点所讲的那些标准着色器所替代了。不幸的是，没有什么很好的办法能够将旧着色器完美的迁移只新版本的着色器。但是你可以通过下面这个表格着重理解如何通过配置标准着色器去模拟unity4的旧着色器的效果：</p><div class="table-wrapper"><table><tr><th>Shader<th>Unity 4<th>Unity 4 (Legacy)<th>Unity 5<tr><td>Diffuse<td>Diffuse Lambert<td>Legacy Shader/Diffuse Lambert<td>Standard Physically-based rendering: Metallic Workflow<tr><td>Specular<td>Specular Blinn-Phong<td>Legacy Shader/Specular Blinn-Phong<td>Standard (Specular setup) Physically-based rendering: Specular Workflow<tr><td rowspan="2">Transparent<td>Specular Blinn-Phong<td>Legacy Shader/Transparent Vertex-Lit<td>Standard Rendering Mode: Transparent<tr><td>Transparent Cutout Vertex-Lit<td>Legacy Shader/Transparent Cutout Vertex-Lit<td>Standard Rendering Mode: Cutout</table></div><p>你可以在旧材质的<strong>检查器面板(Inspector)</strong>上通过<strong>着色器(Shader)</strong>下拉菜单改变它所使用的着色器。所有你需要做的就是简单的选择适当的标准材质。如果你的旧着色器使用了纹理，颜色和发现题图，那么在新版本的标准着色器上也会自动使用。当然为了更好的接近之前旧版本着色器的光照模型，你可能需要配置标准着色器的相关参数。 下图展示的是常见的斯坦福兔(<em>Stanford bunny</em> )，它们分别使用旧版本的漫反射着色器(右)，被转换的标准着色器(左)，和把<strong>平滑度(Smoothness)</strong>设置成0的标准着色器(中)：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram4.png" /></div><li><p><strong>迁移用户自定义的着色器</strong></p><p>如果你以前在Unity4上有写自定义的着色器，很有可能在Unity5中能直接正常使用。即使如此，Unity也有可能在着色器的工作原理上做了细小的改动，这些改动是可能引发一些错误和不一致性。有个变化最明显的重要参数就是光的强度。 光在Unity5中是原来亮度的两倍。所有的旧版本着色器在重写的的时候都应该考虑到这一点；如果你升级了你的着色器或者切换到标准着色器，你不会发现有任何的不同。但是如果你是自己写的光照模型，那么你就要注意确认光的强度不能再乘以二了。我们就用下面的代码举例来确认这种变化：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// Unity 4</span>
<span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="p">(</span><span class="n">diff</span> <span class="p">*</span> <span class="n">atten</span> <span class="p">*</span> <span class="m">2</span><span class="p">);</span>
<span class="c1">// Unity 5</span>
<span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="p">(</span><span class="n">diff</span> <span class="p">*</span> <span class="n">atten</span><span class="p">);</span>
</pre></table></code></div></div><p>如果你还没有写过着色器，大可不必惊慌：光照模型会在第三章，<strong>理解光照模型</strong> 中全面详细的讲解。</p><p><strong>注意</strong></p><p>Unity5对着色器的处理相比于Unity4来说还有一些其他的变化，你可以下面这个网址中查看所有着色器在Unity5中的处理方式的变化</p><p><a href="http://docs.unity3d.com/Manual/UpgradeGuide5-Shaders.html">http://docs.unity3d.com/Manual/UpgradeGuide5-Shaders.html</a>。</p></ul></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="MLSUU_how_it_works"></span></p><p>着色器的编写需要权衡画面表现和效率；效果逼真的着色器需要极大的计算量，可能导致严重的延迟。所以，有一点很重要，就是只使用我们确切需要的效果：如果一个材质不需要高光反射，那么就不要在着色器中去计算它们。这也是在Unity4中把这些效果拆分成了很多不同着色器的主要原因。 新版本的标准着色器有潜力替换掉先前旧版本的着色器，因为它把法线贴图，透明度和反射都包括在内了。然而，这个标准着色器经过巧妙的优化，使它能够只去计算用到的效果，没用到的效果就不计算。尽管这样，标准着色器主要还是设计用于模拟现实的材质。相比较而言，漫反射和高光反射着色器并不是为模拟现实的材质设计的。 这就是为什么从旧版本的着色器切换到标准着色器时，游戏对象在渲染的时候通常回发生一些细小的变化的原因。</p></ul><hr /><ul><li><p><strong>额外内容</strong><span id="MLSUU_see_also"></span></p><p>第三章， <strong>理解光照模型</strong>, 将会深入探索漫反射和高光反射着色器的作用原理。尽管在Unity5中，它们已经被弃用了，但是如果你想要设计新的光照那么理解它们还是有必要的。</p><p>第四章，<strong>Unity 5中基于物理原理的渲染</strong> ，将会介绍如何在Unity5中展现标准着色器的潜力。</p></ul><hr /><p><span id="APTS"></span></p><h3 id="给着色器添加属性">给着色器添加属性</h3><p>着色器的属性对于着色器管线来说时非常重要，因为艺术家或者用户想要添加纹理或者调整着色器的值都是通过著色器的属性来修改的。着色器的属性在材质的<strong>检查器面板(Inspector )</strong>中会提供GUI，提供图形界面让玩家去调整一个着色器，不用打开额外的编辑器。用Visual Studio Code打开你的着色器代码，从第2行到第7行的代码块就是着色器的<strong>属性(Properties )</strong>。当前的这个着色器，他会有一个叫<strong>_MainTex</strong>的属性。如果你查看使用了这个着色器的材质，你能注意到着色器的<strong>检查器面板(Inspector )</strong>中有一个<strong>纹理(texture )</strong>的GUI元素。着色器中的这行代码为我们创建了这个GUI元素。还有就是，Unity工作人员通过编码方式和努力的迭代，让你改变属性的这个过程非常快速高效。</p><hr /><ul><li><p><strong>始前准备</strong><span id="APTS_getting_ready"></span></p><p>让我们来了解一下这个过程在<strong>标准漫反射(StandardDiffuse)</strong>着色器中是如何工作的，为此我们要创建自己的属性并且学习更多相关的着色器语法。比如我们会修改之前创建的着色器。在这个修改的着色器中，不适用纹理，而是仅仅使用能从<strong>检查器面板(Inspector)</strong>直接修改的颜色和其他的属性。开始之前，我们先复制一个<strong>标准漫反射(StandardDiffuse)</strong>着色器。你可以在<strong>项目(Project)</strong>面板中选中它，然后按<strong>Ctrl + D</strong>。这样就会复制一份新的<strong>StandardDiffuse 1</strong>的着色器。【书上的写法有问题，在Inspector面板根本不能选中复制，应该在项目面板中选中在复制】 <strong>注意</strong> 你最好给你复制的这个着色器在第一行代码处给它一个恰当的名字。比如，<strong>Shader “CookbookShaders/StandardDiffuse”</strong>可以告诉Unity这个着色器叫<strong>StandardDiffuse</strong>并且把它分组到<strong>CookbookShaders</strong>这个着色器组。如果你是通过<strong>Ctrl + D</strong>复制的着色器，你新复制的这个着色器跟被复制的着色器就会用相同的名字和分组。为了避免混淆，一定要记得复制着色器代码之后，在第一行那里修改着色器的名字，给一个不会重复的名字。</p></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="APTS_how_to_do_it"></span></p><p>当<strong>StandardDiffuse2</strong>这个着色器准备好后，我们就可以开始修改它的属性了：</p><ol><li>在着色器的<strong>属性(Properties )</strong>块中，删除着色器中下面的属性代码，整行删除：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Albedo (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
</pre></table></code></div></div><li>当我们移除这个必要的属性后，着色器不会被编译直到所有跟<strong>_MainTex</strong>的代码都被移除。然我们删除另外有引用的代码：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
</pre></table></code></div></div><li>原始的着色器使用<strong>_MainTex</strong>给游戏模型上色。为了改变这个，我们替换掉<strong>surf()</strong>方法的第一行代码，通过如下代码：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="n">fixed4</span> <span class="n">c</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">;</span>
</pre></table></code></div></div><li>当你修改完成之后，返回Unity，然后着色器会被重新编译， 之后我们的材质<strong>检查器</strong>面板中就没有纹理选择这一选项了。 为了完成这个着色器的调整，让我们添加一个额外的属性给着色器，看看会有什么效果。输入下面的代码：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="nf">_AmbientColor</span> <span class="p">(</span><span class="s">"Ambient Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
</pre></table></code></div></div><li>我们在材质的<strong>检查器</strong>面板中添加了另一个颜色选项。现在，让我们来额外添加另一种类型的属性来找找属性语法的感觉。添加下面的代码到<strong>属性</strong>代码块中：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="nf">_MySliderValue</span> <span class="p">(</span><span class="s">"This is a Slider"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">10</span><span class="p">))</span> <span class="p">=</span> <span class="m">2.5</span>
</pre></table></code></div></div><li><p>我们创建了其他两种不同类型的GUI元素，它们可以让我们与着色器进行可视化的交互。我们这次创建了一个叫做<strong>This is a Slider</strong>的滑动条，就如下图所示：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram5.png" /></div></ol><p>着色器的属性让你可以通过可视化的方式调整着色器，而不用在着色器自己的代码中调整。 下一个知识点将会为你介绍如何利用这些属性创建一些更有趣的着色器。 <strong>注意</strong> 尽管属性属于着色器，但是着色器上属性的值却是保存在材质上的。不同的材质可以很安全的共用相同的着色器。从另一方面说，修改材质上的属性的值，将会影响到所有使用了该材质的游戏对象的外观。</p></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="APTS_how_it_works"></span></p><p>每一个Unity的着色器都有它想要的内建的代码结构。<strong>属性</strong>代码块就是Unity所期望的功能之一。<strong>属性</strong>代码块的目的是让着色器编程人员能快速的创建GUI交互元素，并且将GUI元素与着色器代码相关联起来。那些你在着色器<strong>属性</strong>面板中申明的属性，能让你在着色器代码中使用，从而修改着色器中的一些值，颜色和纹理。 定义一个属性的语法[也可以叫语义，也可以叫语法糖]如下：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram6.png" /></div><p>让我们来解释一下这个示意图。 当你第一次开始写一个新的属性时，你需要给这个书信一个<strong>变量名(Variable Name)</strong>。这个变量名能让着色器使用并且能让着色器代码获得来自该变量名绑定的GUI元素的值。这给我们节约了大量的时间因为我们不用自己来创建这么一个系统。属性的下一个元素时<strong>检查器面板GUI名称( Inspector GUI Name )</strong>和属性的<strong>类型(Type)</strong>，这两个元素放在一对括号中。当玩家想要交互和调整着色器时，<strong>检查器面板GUI名称( Inspector GUI Name )</strong>将会在材质的<strong>检查器面板(Inspector tab)</strong>中展示。<strong>类型(Type)</strong>就是这个属性想要控制的数据类型。在Unity着色器中，有很多属性可以使用的类型。下面这个表展示了我们在着色器中可以使用的变量类型：</p><div class="table-wrapper"><table><tr><th colspan="2" align="center">Surface Shader property types<tr><td>Range (min, max)<td>创建一个浮点类型的滑动条属性，值从最小值到最大值[min最小值，max最大值]<tr><td>Color<td>在<b>检查器面板(Inspector tab)</b>中创建一个颜色选取框，当你打开的时候会弹出一个调色板，颜色值(R,G,B,A)[四个浮点数，分别表示红，绿，蓝，透明度]<tr><td>2D<td>创建了纹理选取框的GUI元素，可以让玩家通过拖拽的方式给着色器一张纹理<tr><td>Rect<td>创建一个非2次幂纹理[NPOT]选取框，功能更<b>2D</b>属性类似<tr><td>Cube<td>在<b>检查器面板(Inspector tab)</b>创建一个立方体纹理[大家想想天空盒],可以让玩家拖拽立方体纹理到着色器中<tr><td>Float<td>在<b>检查器面板(Inspector tab)</b>中创建一个浮点型的值，但是没有滑动条<tr><td>Vector<td>创建一个有四个值的属性，能让你表示方向或者颜色</table></div><p>最后就是这些属性的<strong>默认值(Default Value)</strong>了。可以在着色器代码中简单的给着色器的属性设置特定的值。在上一个图片属性改成颜色属性的列子中，属性</p><p><strong>_AmbientColor</strong>的默认值是一个<strong>Color</strong>类型的默认值，其值为<strong>1，1，1，1</strong>。这个颜色属性需要一个<strong>RGBA</strong>或者<strong>float4</strong>或者<strong>r,g,b,a=x,y,z,w</strong>赋值。颜色属性第一次创建的时候默认值时白色。</p></ul><hr /><ul><li><p><strong>额外内容</strong><span id="APTS_see_also"></span></p><p>着色器属性的文档在Unity手册中的位置在<a href="http://docs.unity3d.com/Documentation/Components/SL-Properties.html">http://docs.unity3d.com/Documentation/Components/SL-Properties.html</a> ***</p></ul><p><span id="UPISS"></span></p><h3 id="使用表面着色器的属性">使用表面着色器的属性</h3><p>现在我们已经为着色器创建了一些属性，这里我们将要正式的把这些属性跟着色器关联起来，这些属性就像着色器的调节器一样，可以让材质拥有更好的交互性。</p><p>我们可以在材质的<strong>检查器面板(Inspector tab)</strong>使用着色器属性的值，因为我们为这个属性添加了一个变量名，但是如果你在着色器代码中想要通过这个变量名来获得这个值，我们仍然还有很多事情要做。</p><hr /><ul><li><p><strong>操作步骤</strong><span id="UPISS_how_to_do_it"></span></p><p>下面的步骤展示了如何在表面着色器中使用属性：</p><ol><li>开始之前，我们先删除下面的行的代码,就好像我们在章节<strong><em>创建一个基本的标准着色器</em></strong>中删除属性的操作步骤一样，删除<strong>_MainTex</strong>属性：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Albedo (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
</pre></table></code></div></div><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
</pre></table></code></div></div><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="p">*</span> <span class="n">_Color</span><span class="p">;</span>
</pre></table></code></div></div><li>下一步，添加下面这些行的代码到着色器代码中，添加到<strong>CGPROGRAM</strong>下面, add the following lines of code to the shader, below the CGPROGRAM line:<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">float4</span> <span class="n">_AmbientColor</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_MySliderValue</span><span class="p">;</span>
</pre></table></code></div></div><li>当第二部完成之后，我们就可以在着色器中使用属性的值了。我们把<strong>_Color</strong>属性的值与<strong>_AmbientColor</strong>值相加，并且把两者的结果赋值给<strong>o.Albedo</strong>。为了达成目的，我们需要在着色器代码中的<strong>surf()</strong>方法中添加如下代码：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> 
<span class="p">{</span>
   <span class="n">fixed4</span> <span class="n">c</span>        <span class="p">=</span> <span class="nf">pow</span><span class="p">((</span><span class="n">_Color</span> <span class="p">+</span> <span class="n">_AmbientColor</span><span class="p">),</span> <span class="n">_MySliderValue</span><span class="p">);</span>
   <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span>        <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
   <span class="n">o</span><span class="p">.</span><span class="n">Metallic</span>      <span class="p">=</span> <span class="n">_Metallic</span><span class="p">;</span>
   <span class="n">o</span><span class="p">.</span><span class="n">Smoothness</span>    <span class="p">=</span> <span class="n">_Glossiness</span><span class="p">;</span>
   <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span>         <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li>最终你的代码将会是如下所示。如果你在你的VSCode中保存好然后返回Unity编辑器，你的着色器将会重新编译。 如果没有什么错误，那么现在你可以修改材质的环境光和自发光的颜色，当然也可以通过滑动条增加最终颜色的饱和度。听巧妙的噢。<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"CookbookShaders/StandardDiffuse3"</span> 
<span class="p">{</span>
   <span class="c1">// We define Properties in the properties block</span>
   <span class="n">Properties</span> 
   <span class="p">{</span>
       <span class="nf">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
       <span class="nf">_AmbientColor</span><span class="p">(</span><span class="s">"Ambient Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
       <span class="nf">_MySliderValue</span><span class="p">(</span><span class="s">"This is a Slider"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">10</span><span class="p">))</span> <span class="p">=</span> <span class="m">2.5</span>
   <span class="p">}</span>
   <span class="n">SubShader</span> 
   <span class="p">{</span>
       <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
       <span class="n">LOD</span> <span class="m">200</span>
       <span class="c1">// We need to declare the properties variable type inside of the </span>
       <span class="c1">//CGPROGRAM so we can access its value from the properties block.</span>
       <span class="n">CGPROGRAM</span>
       <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Standard</span> <span class="n">fullforwardshadows</span>
       <span class="err">#</span><span class="n">pragma</span> <span class="n">target</span> <span class="m">3.0</span>
       <span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span> <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;};</span>
       <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>
       <span class="n">float4</span> <span class="n">_AmbientColor</span><span class="p">;</span>
       <span class="kt">float</span>  <span class="n">_MySliderValue</span><span class="p">;</span>
       <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> 
       <span class="p">{</span>
           <span class="c1">// We can then use the properties values in our shader</span>
           <span class="n">fixed4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">pow</span><span class="p">((</span><span class="n">_Color</span> <span class="p">+</span> <span class="n">_AmbientColor</span><span class="p">),</span> <span class="n">_MySliderValue</span><span class="p">);</span>
           <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
           <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="n">ENDCG</span>
   <span class="p">}</span>
   <span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>  
</pre></table></code></div></div></ol><li><p><strong>提示</strong> <strong>下载示例代码</strong> 你可以在<strong>Packt</strong>网站登陆后，下载所有已购买书籍的所有示例代码文件，下载地址：<a href="http://www.packtpub.com">http://www.packtpub.com</a>。如果你是在别处购买的书，那么请访问： <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>然后注册，以便通过邮件直接获取相关的代码文件。</p><li><p><strong>注意</strong> <strong>pow(arg1, arg2)</strong>这个方法是内置的，他的功能跟数学的幂函数<strong>power</strong>是等价的。第一个参数是底数，第二参数是指数 。想了解更深入的了解<strong>pow()</strong>方法，请去看Cg语言的教程。下面这个网址提供了非常棒的资源，能让你学习更多有关着色器的知识，并且里面有Cg着色器语言的所有函数的表：<br /> <a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html</a> 下面的屏幕截图展示了通过材质的<strong>检查器面板(Inspector tab)</strong>来控制材质的属性，从而控制材质的颜色和饱和度：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram7.png" /></div><hr /><li><p><strong>原理介绍</strong><span id="UPISS_how_it_works"></span></p><p>当你在<strong>属性(Properties )</strong>代码块中声明一个新的属性时，等于是在材质的<strong>检查器面板( Inspector tab)</strong>给着色器添加了可以访问调整值[tweaked value]的方式。这个值存储在这个属性的变量名中。在这个例子中，<strong>_AmbientColor</strong>，<strong>_Color</strong> 和<strong>_MySliderValue</strong>这三个变量就是我们用来保存调整值的。为了让你能够在<strong>SubShader{}</strong> 这个代码块中使用这些值，你需要在这个代码块中对应创建三个变量，而且这三个变量的名字要跟属性代码块中的变量名保持一致。这样的话Unity会自动把<strong>SubShader{}</strong>代码块和属性代码块中的变量关联起来，然后让着色器知道这些变量使用的是相同的数据。另外，这个属性声明同时也告诉我们在<strong>SubShader{}</strong>代码块中对应的变量的数据类型，在后续有关着色器的优化相关的章节中，会用到这些。</p><p>当你再<strong>subshader</strong>代码块中创建好变量后，接下来你就可以再<strong>surf()</strong>方法中使用它们的值。在这个例子中，<strong>_Color</strong>，<strong>_AmbientColor</strong>与<strong>_MySliderValue</strong>这三个变量获得了来自材质的<strong>检查器面板(Inspector tab)</strong> 对应的值。变量<strong>_Color</strong>跟变量<strong>_AmbientColor</strong>这两个值相加，并且把这个值当作底数，<strong>_MySliderValue</strong>的值当作指数，进行幂运算。</p><p>大多数着色器都是从一个标准着色器开始，然后一步一步修改它直到它们符合设计的样子。我们现如的这个例子为以后需要散射组件的表面着色器打好了基础。</p><p><strong>注意</strong> 材质时一种<strong>资源(assets)</strong>。这意味着，当你的游戏在编辑器中运行时，你对它的任何改变都将会是永久的[这里解释一下，一般在Unity编辑器运行时，你对游戏做的修改，在停止运行后，又会恢复到运行之前的状态，这里材质不一样，修改之后，即使停止运行，它也不会恢复]。如果你不小心错误修改了属性的值，你可以通过快捷键<strong><em>Ctrl + Z</em></strong>取消这个修改。</p></ul><hr /><ul><li><p><strong>相关补充</strong><span id="UPISS_there_is_more"></span></p><p>跟其他一些编程语言一样，Cg也是不允许有错误。如果你的着色器代码中有错误的话，着色器将不会起作用。当着色器不起作用时，你的材质会因为没有着色器而以品红的方式渲染：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram8.png" /></div><p>当一个脚本没有被编译，Unity引擎会禁止你的游戏导出或者运行。 然而，着色器中有错误，Unity并不会阻止你运行你的游戏。如果你的着色器呈现出品红色，那么就应该检查一下到底哪里出现了问题。当你在Unity的编辑器中选中这个报错的着色器，那么你可以在<strong>检查器面板(Inspectortab)</strong>中看到一大串错误：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram9.png" /></div><p>尽管错误提示展示了错误所在的行，但是通常不一定是引起错误的正真原因。上一张示例图所展示的错误是因为删除了了<strong>SubShader{}</strong>代码块中的<strong>sampler2D _MainTex</strong>变量引起的。 然而报错的地方是试图去访问这个未定义的变量所在的代码行。找到错误并且修复的过程就是我们常说的<strong>debug</strong>。你最常用的一些错误检查如下：</p><ul><li><p>忘记括号匹配。 如果忘记用花括号对代码块进行配对匹配，那么编译器就会在代码文档的最后，开始或者新的代码块中提示错误。</p><li><p>忘记写分号结束语句。这是最常见的错误，同时也是最容易定位和修复的错误。通常会在下一行开始产生一个错误。</p><li><p>在<strong>属性(Properties)</strong>代码块中定义了一个属性，但是没有在<strong>SubShader{}</strong>代码块中定义对应的变量。【这两者是需要成对出现的，也就是说在<strong>属性(Properties)</strong>块里面定义了一个新的属性，那么在<strong>SubShader{}</strong>代码块中就需要声明一个与之对应的变量】</p><li><p>更Unity中的C#脚本不一样，Cg语言中的浮点值不需要在后面加<strong>f</strong>来表示浮点类型：浮点值1.0就写作<strong>1.0</strong>，而不是<strong>1.0f</strong>。</p></ul><p>着色器中提示的错误很具有误导性，特别是因为它们那严格的语法约束。如果看不懂错误什么意思，那就直接百度或者谷歌。 或者去Unity的论坛搜索一下看看，里面可能就有跟你遇到相同问题（修复了相同问题）的开发者。</p></ul><hr /><ul><li><p><strong>额外内容</strong><span id="UPISS_see_also"></span></p><p>在<a href="">第二章</a>，<strong><em>表面着色器和纹理映射</em></strong>，我们会了解如何去掌握<strong>表面着色器(Surface Shaders)</strong>跟它们的<strong>属性(properties )</strong>。如果使用着色器的所有潜能和特性，到底能做些什么？如果你对这个问题感兴趣，你应该去看一看<a href="">第十章</a>，<strong><em>更高级的着色器技术</em></strong> 。里面有本书的一些最高级的着色器技术。</p></ul><hr /><h2 id="第二章-表面着色器和纹理映射-">第二章 表面着色器和纹理映射 <span id="SSTM"></span></h2><p>在这一章节，我们将会探索表面着色器的使用。我们会用一个非常简单的磨砂材质开始讲起，然后会在后面讲解全息投影和高级的地形混合。 我们将能够使用纹理制作动画效果，混合等，或者用着色器去驱动我们想要的属性。在这一章你将会学习下面一些表面着色器的使用方法：</p><ul><li>漫反射的着色处理<li>使用包组<li>向着色器添加纹理<li>通过改变UV值来移动纹理<li>法线贴图<li>创建一个带透明度的材质<li>创建一个有全息效果的着色器<li>纹理的压缩和混合<li>在地形的表面绘制一个圆 ***</ul><h3 id="介绍-1">介绍<span id="SSTM_introduction"></span></h3><p>我们在<strong>第一章</strong>，<strong><em>创建你的第一个着色器</em></strong> 已经介绍了表面着色器，这是Unity引擎中的主要着色器类型。在这一章我们将更详细的向你展示它到底是什么以及它具体是如何工作的。通常来说，每个表面着色器都有两个重要的步骤。 首先，你需要在材质中描述你想指定的物理属性，比如漫反射的颜色，光滑度和透明度等。 这些属性将会在一个叫<strong>表面函数 surface function</strong>的函数中初始化并且保存在一个叫<strong>表面输出 surface output</strong>的结构体中。其次，<strong>表面输出 surface output</strong>结构体传入到一个<strong>光照模型 lighting model</strong>中。这是一个特殊的函数，这个函数会获取场景周围的光照信息。所有获得的这些信息将会被用于去计算你的模型最终在每一个像素点上最终呈现出来的颜色。这个光照函数就是着色器真正进行计算的地方，而正是这部分代码，决定了使用这个着色器材质的光照表现。下面的示意图简单的总结了表面着色器时如何工作的。在<strong>第三章</strong>，<strong><em>理解光照模型</em></strong> 将探索自定义光照模型，当学习到<strong>第五章</strong>，<strong><em>顶点函数</em></strong> 会着重讲解顶点修改器：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram10.png" /></div><hr /><h3 id="漫反射的着色处理">漫反射的着色处理<span id="SSTM_diffuse_shading"></span></h3><p>在我们开始学习纹理映射之前，了解漫反射材质时如何工作的显得尤为重要。具体的一些物体也许会有统一的光照和光滑的表面，但是可以还是不够光滑来反射光线。磨砂材质是漫反射着色器使用的一个典型代表 。然而我们现实世界中，完全漫反射材质是不存在的；漫反射着色器是一种成本相对比较低的实现方式并且在低多边形风格中有着大量的应用。</p><hr /><ul><li><p><strong>始前准备</strong> <span id="SSTM_getting_ready"></span></p><p>有好几种方式来创建你自己的漫反射着色器。最快的一个方式是在Unity5中创建一个表面着色器然后编辑它，移除所有的纹理，跟我们前面学习的<strong>第一章</strong>，<strong><em>创建你的第一个着色器</em></strong> 类似。</p></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="SSTM_how_to_do_it"></span></p><p>让我们开始创建我们的标准着色器，首先在Unity中新建一个标准着色器，然后按照下面的步骤进行修改：</p><ol><li>首先在着色器的属性列表移除除<strong>_Color</strong>之外的所有属性：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
</pre></table></code></div></div><li>在<strong>SubShader{}</strong>代码块中，移除<strong>_MainTex</strong>，<strong>_Glossiness</strong>和<strong>_Metallic</strong>这三个变量。但是你不能删除<strong>uv_MainTex</strong> 这个变量，因为<strong>Cg</strong>着色器语言不允许输入结构体为空。这个值会被Unity简单的忽略。<li>删除<strong>surf()</strong>函数内代码内容并且把下面代码放在里面：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</pre></table></code></div></div><li>最终，你的着色器代码应该如下所示：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"CookbookShaders/Diffuse"</span> 
<span class="p">{</span>
 <span class="n">Properties</span> 
 <span class="p">{</span>
     <span class="nf">Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="n">SubShader</span> 
 <span class="p">{</span>
   <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
   <span class="n">LOD</span> <span class="m">200</span>
   <span class="n">CGPROGRAM</span>
   <span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Standard</span> <span class="n">fullforwardshadows</span>
   <span class="err">#</span><span class="n">pragma</span> <span class="n">target</span> <span class="m">3.0</span>
   <span class="k">struct</span> <span class="nc">Input</span> 
   <span class="p">{</span>
       <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
   <span class="p">};</span>
   <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>
   <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> 
   <span class="p">{</span>
       <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="n">ENDCG</span>
 <span class="p">}</span>
 <span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</pre></table></code></div></div><p>当这个着色器从标准着色器修改调整之后，那么这个着色器将会使用基于物理原理的渲染去模拟光在模型表面的表现。如果你想试着获得一个看起来不那么真实表现的话，你可以直接修改<strong>#pragma</strong>部分，这样着色器就可以使用<strong>Lambert</strong>而不是<strong>Standard</strong>。如果你这样修改了的话，那么你还应该用<strong>SurfaceOutput</strong>替换掉**SurfaceOutputStandard **。 按照书上的意思，应该是改成下图所示：</p></ol><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram11.png" /></div></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="SSTM_how_it_works"></span></p><p>通过<strong>表面输出surface output</strong>，着色器可以让你材质的渲染属性跟<strong>光照模型lighting model</strong>进行沟通。 它基本封装了光照模型需要的所有参数。很明显，不同的关照模型肯定有着不同的表面输出结构。下表列出了在Unity中使用的三种主要的输出结构以及它们能如何使用：</p><div class="table-wrapper"><table><thead><tr><th>Type of shaders<th>Unity 4<th style="text-align: left">Unity 5<tbody><tr><td>Diffuse<td>Any Surface Shader:SurfaceOutput<td style="text-align: left">Standard:SurfaceOutputStandard<tr><td>Specular<td>Any Surface Shader:SurfaceOutput<td style="text-align: left">Standard (Specular setup):SurfaceOutputStandardSpecular</table></div><p><strong>表面输出SurfaceOutput</strong>结构体所包含的属性如下：</p><ul><li><p><strong>fixed3 Albedo</strong>: 材质的漫反射颜色</p><li><p><strong>fixed3 Normal</strong>: 空间中法线的切线，如果有法线的话</p><li><p><strong>fixed3 Emission</strong>:这是材质指定的光的颜色 （如果是<strong>标准着色器Standard Shaders</strong>的话，它会被定义为<strong>half3</strong>类型）</p><li><p><strong>fixed Alpha</strong>: 这是材质的透明度</p><li><p><strong>half Specular</strong>: 这是镜面反射度【就是看起来多像镜面？】，值的变化是从0到1</p><li><p><strong>fixed Gloss</strong>: 这是镜面强度</p></ul><p><strong>标准表面输出SurfaceOutputStandard</strong>结构体包含以下的属性：</p><ul><li><strong>fixed3 Albedo</strong>: 这是材质的基本颜色(不管是镜面反射还是漫反射)<li><strong>fixed3 Normal</strong>：空间中法线的切线，如果有法线的话<li><strong>half3 Emission</strong>: 跟表面输出结构体一样的意思，不过在这里定义为<strong>half3</strong>类型，而在表面输出结构体中定义为<strong>fixed3</strong>类型。<li><strong>fixed Alpha</strong>：同表面输出结构体<li><strong>half Occlusion</strong>: 这个是遮挡（默认是1）<li><strong>half Smoothness</strong>: 这个是光滑度 (0 = 粗糙, 1 = 光滑)<li><strong>half Metallic</strong>:金属质感 0 = 无金属质感, 1= 金属</ul><p><strong>标准镜面表面输出SurfaceOutputStandardSpecular</strong>结构拥有如下属性：</p><ul><li><strong>fixed3 Albedo</strong>：同上<li><strong>fixed3 Normal</strong>：同上<li><strong>half3 Emission</strong>：同上<li><strong>fixed Alpha</strong>：同上<li><strong>half Occlusion</strong>：同上<li><strong>half Smoothness</strong>：同上<li><strong>fixed3 Specular</strong>: 这个是镜面反射的颜色，这个跟表面叔叔结构体中的镜面反射有很大的不同，因为这里是用颜色表示，而在表面输出结构体中只是一个简单的值</ul><p>正确的给表面输出结构体赋值，初始化，是使用表面着色器的前提。</p></ul><hr /><h2 id="使用包组">使用包组<span id="UPA"></span></h2><p>笼统的讲，显示器上每一个像素点都至少会执行一次。这也是为什么GPU要设计高度优化的并行架构的原因。同样的在Cg语言的标准变量类型和操作符中，这种设计哲学也很明显。理解它们，不仅仅是为了正确的使用着色器，同时也是为了能够写出更高效的着色器。</p><hr /><ul><li><p>操作步骤<span id="UPA_how_to_do_it"></span></p><p>在Cg语言中有两种类型的变量：<strong>单精度值single</strong>和<strong>包组packed arrays</strong>。后者很容易辨别因为这种类型通常会以数字结尾，比如<strong>float4</strong>，<strong>int4</strong>等等。正如它们的名字所表示的一样，这些类型的变量跟我们编程语言中的<strong>结构体structs</strong>类似，这也意味着每一个这样的变量包含了多个单精度值。在Cg语言中我们称之为<strong>包组packed arrays</strong>，尽管它们并非真的是传统意义上的数组。</p><p>在包组中的元素能像常见的结构体那样访问。通常它们表示成<strong>x</strong>，<strong>y</strong>，<strong>z</strong> 和<strong>w</strong> 。然而Cg语言还有另一种表示，就是<strong>r</strong>，<strong>g</strong>，<strong>b</strong>，<strong>a</strong>。尽管你使用<strong>x</strong>或者<strong>r</strong>去表示都是可以的，但是对于代码阅读者来说它们之间的区别就非常的大了。事实上，在着色器编程中，经常涉及到的就是位置和颜色的计算。你可能对下面的标准着色器代码中的代码片段还有印象吧：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</pre></table></code></div></div><p>在这里，<strong>o</strong>是一个结构体而<strong>_Color</strong>就是一个包组。这也是为什么Cg要禁止上面提到的两种表示进行混用的原因：你不能使用<strong>_Color.xgz</strong>。</p><p>这里还有一个很重要的包组的特性，这种特性在C#中没有：<strong>swizzling</strong>[这个不知道怎么翻译]。Cg允许仅通过简单的一行代码就对包组内的元素进行寻址和重新排序。又是下面在标准着色器中熟悉的代码片段：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>Albedo</strong> 是一个 <strong>fixed3</strong>类型，也就是说它里面包含了三个<strong>fixed</strong>类型的值。 然而<strong>_Color</strong> 是一个<strong>fixed4</strong>类型的定义。由于<strong>_Color</strong>定义包含的元素比 <strong>Albedo</strong>定义包含的元素要多，直接赋值的话，由于不匹配，肯定会产生一个编译错误。如果用C#代码来进行同样的操作，代码如下所示：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span><span class="p">.</span><span class="n">r</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>
<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span><span class="p">.</span><span class="n">g</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">g</span><span class="p">;</span>
<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span><span class="p">.</span><span class="n">b</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
</pre></table></code></div></div><p>相比于C#代码，在Cg语言中，我们可以用如下代码简写：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</pre></table></code></div></div><p>Cg语言也允许对元素进行重新排序。比如，通过<strong>_Color.bgr</strong>这个代码去交换红色和蓝色通道的颜色。</p><p>最后要讲一点，当一个单精度值赋值给包组时，这个值会被复制到包组的所有元素中去：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="c1">// Black =(0,0,0)</span>
<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="c1">// White =(1,1,1)</span>
</pre></table></code></div></div><p>这个就是Cg语言中的<strong>smearing</strong>特性。</p><p><strong>Swizzling</strong>还可以被用作表达式的左值，不过仅当包组的具体元素能被这样使用：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span><span class="p">.</span><span class="n">rg</span> <span class="p">=</span> <span class="n">_Color</span><span class="p">.</span><span class="n">rg</span><span class="p">;</span>
</pre></table></code></div></div><p>上面这种特性，叫做<strong>masking</strong>.</p></ul><hr /><p><strong>压缩矩阵</strong></p><p>真正发挥<strong>swizzling</strong>特性潜力的是在它应用于压缩矩阵的时候。Cg语言允许像<strong>float4x4</strong>这种类型，这是一个四行四列的矩阵。你可以使用<strong><em>_mRC</em></strong>标记访问矩阵中的单个元素，<strong>R</strong>表示元素所在的行而<strong>C</strong>表示元素所在的列：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  <span class="n">float4x4</span> <span class="n">matrix</span><span class="p">;</span> 
  <span class="c1">// ... </span>
  <span class="kt">float</span> <span class="n">first</span> <span class="p">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">_m00</span><span class="p">;</span> 
  <span class="kt">float</span> <span class="n">last</span> <span class="p">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">_m33</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>_mRC</strong>标记还可以接连使用：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="n">float4</span> <span class="n">diagonal</span> <span class="p">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">_m00_m11_m22_m33</span><span class="p">;</span>
</pre></table></code></div></div><p>如果要获取矩阵的整行，可以使用中括号：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="n">float4</span> <span class="n">firstRow</span> <span class="p">=</span> <span class="n">matrix</span><span class="p">[</span><span class="m">0</span><span class="p">];</span> 
  <span class="c1">// Equivalent to </span>
  <span class="n">float4</span> <span class="n">firstRow</span> <span class="p">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">_m00_m01_m02_m03</span><span class="p">;</span>
</pre></table></code></div></div><hr /><ul><li><p>额外内容<span id="UPA_see_also"></span></p><p>包组是Cg语言中最棒的特性之一，你可以从下面的连接获得关于包组的更多信息：</p><p><a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html</a></p></ul><hr /><h2 id="向着色器添加纹理-">向着色器添加纹理 <span id="ATTS"></span></h2><p>通过纹理，可以很容易让着色器变得生动起来，获得非常真实的效果。为了更有效的使用纹理，我们需要了解一张2D图片是如何映射到3D模型中去的。 这个映射的过程称之为<strong>纹理映射texture mapping</strong>，为了完成映射，我们在使用的模型和着色器上还有额外的工作。模型实际上是由很多的三角形拼接而成的；而三角形的每个顶点都保存有着色器可以访问的各种数据。 其中很重要的一个信息就是<strong>UV信息 (UV data)</strong>。 它包含两个坐标，<strong>U</strong>和<strong>V</strong>，其取值范围是0到1。这两者表示2D图片的像素点坐标的<strong>XY</strong>位置信息，而这些信息将会映射到顶点中去。 UV数据只为顶点表示[意思可能也等价于：UV数据只存在顶点中]； 当三角内的点需要被纹理映射时，GPU会插值最接近的UV值，从而从相应的纹理中找到正确的像素点。下面的图片展示了一张2D纹理映射到3D模型中的三角形中的情况：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram12.png" /></div><p>UV数据保存在3D模型中并且需要3D模型工具去编辑它们。有些模型缺少UV组件，因而它们不支持纹理映射。比如3D模型软件中的默认的那个兔子模型，就没有提供这么一个组件。</p><ul><li><p><strong>始前准备</strong><span id="ATTS_getting_ready"></span></p><p>学习这个知识点的时候，你需要一个有UV数据和纹理的3D模型。然后把它们都导入到Unity中。也可以直接拖拽到Unity编辑器中，会自动导入。因为标准着色器支持默认的纹理映射。我们会用到这一点，而后会详细的介绍它是如何工作的。</p></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="ATTS_how_to_do_it"></span></p><p>用标准着色器给你的模型添加一张纹理异常的简单，按照下面步骤：</p><ol><li><p>创建一个叫<strong>TexturedShader</strong>标准着色器。</p><li><p>创建一个名为<strong>TexturedMaterial</strong>的材质球。</p><li><p>通过拖拽的方式，把着色器赋值给材质，把着色器拖到材质上即可。</p><li><p>选择刚才的材质，然后拖拽模型对应的纹理到一个叫<strong>Albedo(RGB)</strong>的矩形区域中的空白部分。如果你正确的执行了上述步骤，你的材质<strong>检查器面板(Inspector )</strong>会如下图所示：</p></ol><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram13.jpg" /></div><div align="center">标准着色器知道如何通过UV信息把2D图像映射到3D模型中</div><p>.</p><li><p><strong>原理介绍</strong><span id="ATTS_how_it_works"></span></p><p>当通过材质的检查器面板使用标准材质的时候，纹理映射背后的处理过程对于开发者来说是透明的。如果我们想了解它是如何工作的，那我们需要更加详细的了解我们刚才创建的<strong>TexturedShader</strong>着色器。在着色器的<strong>属性Properties</strong>部分，我们可以看到<strong>Albedo (RGB)</strong>的纹理跟代码的关联如下代码所示：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">MainTex</span><span class="p">:</span>
<span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Albedo (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
</pre></table></code></div></div><p>在我们着色器代码中的<strong>CGPROGRAM</strong>代码块部分，纹理被定义为<strong>sampler2D</strong>类型，这是一种标准的2D纹理类型：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
</pre></table></code></div></div><p>紧接着下一行给我们展示了<strong>Input</strong>这个结构。这个结构就是<strong>surface</strong> 函数中得输入参数并且这个结构包含了一个叫做<strong>uv_MainTex</strong>的包组数组：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Input</span> 
<span class="p">{</span>
	<span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>每一次调用<strong>surf()</strong>函数的时候，对应3D模型中的包含<strong>_MainTex **这个UV的</strong>Input <strong>结构都需要被渲染。标准着色器会知道</strong>uv_MainTex <strong>跟</strong>_MainTex **是关联的，并且会自动初始化它。如果你真的很想了解到底UV是怎么从3D模型映射到2D纹理的话，你可以看看<a href=""><strong>第三章, 理解光照模型</strong></a>。</p><p>终于，UV数据被用来在**surface **函数中展示成一张纹理：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="p">*</span> <span class="n">_Color</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>注意</strong></p><p><strong><em>U</em></strong>和<strong><em>V</em></strong>的取值范围都是从0到1，<strong>(0,0)</strong>和<strong>(1,1)</strong>相当于两个相对的角[可以想象成一个是左下角，一个是右上角]。如果你的纹理出现了颠倒的情况，试着把V的值也颠倒就能解决了。</p></ul><hr /><ul><li><p><strong>相关补充</strong><span id="ATTS_there_is_more"></span></p><p>当你把纹理导入到Unity的时候，你就会默认设置一些<strong>sampler2D</strong>类型将要使用的一些属性。 最重要的就是<strong>筛选模式Filter mode</strong>，它决定了一张纹理显示的时候颜色是如何插值的。跟UV数据会准确的指向像素的正中心非常不同；在一些其他的情况中，你也许想对最近的像素之间进行颜色插值从而获得更一致的颜色。下图是示例纹理在<strong>检查器面板Inspector tab</strong>的截屏：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram14.jpg" /></div><p>对于多数的应用程序来说，<strong>双线性Bilinear</strong>提供了一种性能消耗低而且高效方法来对纹理进行平滑的处理方式。然而如果你是创建一个2D游戏，<strong>双线性Bilinear</strong>模式可能会产生模糊块。在这种情况下，你可以使用**点Point **模式来删除来自纹理采样的所有插值。</p><p>当以一个很大的倾斜角去观看一张纹理时，贴图采样似乎会呈现一种看起来不舒服的人工制品。你可以通过设置更高的**Aniso Level **的值来减少这种感觉。这一点对地板贴图和天花板贴图特别有用，可以解决一些小瑕疵导致的贴图观感不连续性的问题。</p></ul><hr /><ul><li><p><strong>额外内容</strong><span id="ATTS_see_also"></span></p><p>如果你想了解更多关于贴图时如何映射到3D模型表面的内部工作原理，你可以通过下面的网址了解相关信息[可能需要用梯子才能访问]：</p><p><a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html</a>。</p><p>如果想了解导入一张2D贴图时完整的可选择项列表，可以通过下面这个相关的网址查询： <a href="http://docs.unity3d.com/Manual/class-TextureImporter.html">http://docs.unity3d.com/Manual/class-TextureImporter.html</a></p></ul><hr /><p><span id="STBMUV"></span></p><h2 id="通过改变uv值来移动贴图">通过改变UV值来移动贴图</h2><p>在当惊的游戏产业中，一个很常见的游戏贴图技术就是允许你对游戏物体表面的贴图进行滚动。这种技术可以让你创建很多效果，比如瀑布，河流，流动的沿江等等。同时这些技术也是制作动画精灵特效的基础，我们会在这一章节的一系列知识点中来讲解这些内容。 首先，让我们来看看在<strong>表面着色器(Surface Shader)</strong>如何创建一个简单的贴图滚动效果。</p><ul><li><p><strong>始前准备</strong><span id="STBMUV_getting_ready"></span></p><p>在这个知识点开始之前，需要你创建一个新的着色器文件和材质。这么做的目的是为了有个干净的着色器，然后我们可以更加方便的学习和观看滚动效果。</p><li><p><strong>操作步骤</strong><span id="STBMUV_how_to_do_it"></span></p><p>闲话少说，我们打开刚才创建的的着色器[<strong>着色器的名字文章中没有说，就自己取一个启动的名字吧</strong>]，然后输入下面每个步骤所展示的代码：</p><ol><li><p>这个着色器需要两个控制贴图滚动的新属性。所以我们添加一个速度属性控制<strong><em>X</em></strong>方向的滚动，添加另一个速度属性控制<strong><em>Y</em></strong>方向的滚动，如下面的代码所示：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> <span class="n">Properties</span>
 <span class="p">{</span>
        <span class="nf">_MainTint</span><span class="p">(</span><span class="s">"Diffuse Tint"</span><span class="p">,</span><span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
        <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Base (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
        <span class="nf">_ScrollXSpeed</span><span class="p">(</span><span class="s">"X Scroll Speed"</span><span class="p">,</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">10</span><span class="p">))</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="nf">_ScrollYSpeed</span><span class="p">(</span><span class="s">"Y Scroll Speed"</span><span class="p">,</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">10</span><span class="p">))</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
            
 <span class="p">}</span>
</pre></table></code></div></div><li><p>修改<strong>CGPROGRAM</strong>代码块中的Cg属性中的变量，创建新的变量[把原来的都删掉，用下面展示的代替]，这样我们就能访问来自着色器属性的值了：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="n">_MainTint</span><span class="p">;</span>
<span class="k">fixed</span> <span class="n">_ScrollXSpeed</span><span class="p">;</span>
<span class="k">fixed</span> <span class="n">_ScrollYSpeed</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
</pre></table></code></div></div><li><p>修改<strong>表面函数surface function</strong>从而修改传递给<strong>tex2D()</strong>函数的UV值。然后，使用内置的<strong>_Time</strong>变量来对UV进行循环播放的动画，这样的话当我们点击Unity中的运行按钮的时候，我们就能看到动画效果了：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre> <span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="c1">// Create a separate variable to store our UVs</span>
   <span class="c1">// before we pass them to the tex2D() function</span>
   <span class="n">fixed2</span> <span class="n">scrollUV</span> <span class="p">=</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">;</span>
   <span class="c1">// Create variables that store the individual x and y</span>
   <span class="c1">// components for the UV's scaled by time</span>
   <span class="k">fixed</span> <span class="n">xScrollValue</span> <span class="p">=</span> <span class="n">_ScrollXSpeed</span> <span class="p">*</span> <span class="n">_Time</span><span class="p">;</span>
   <span class="k">fixed</span> <span class="n">yScrollValue</span> <span class="p">=</span> <span class="n">_ScrollYSpeed</span> <span class="p">*</span> <span class="n">_Time</span><span class="p">;</span>
   <span class="c1">// Apply the final UV offset</span>
   <span class="n">scrollUV</span> <span class="p">+=</span> <span class="nf">fixed2</span><span class="p">(</span><span class="n">xScrollValue</span><span class="p">,</span><span class="n">yScrollValue</span><span class="p">);</span>
   <span class="c1">// Apply textures and tint</span>
   <span class="n">half4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span><span class="n">scrollUV</span><span class="p">);</span>
   <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">_MainTint</span><span class="p">;</span>
   <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
 <span class="p">}</span>
</pre></table></code></div></div></ol><p>下面的图片中的示例就是利用滚动UV的系统来创建的一个自然环境中河流的动画，你可以注意到场景中叫<strong>ScrollingUVs</strong>的特效就是来自于本书提供的代码：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram15.jpg" /></div><li><p><strong>原理介绍</strong><span id="STBMUV_how_it_works"> </span></p><p>这个贴图滚动的着色器中，定义了一系列的属性，这些属性允许玩家增加或者减少滚动效果的速度。这里的关键点是，来自材质的<strong>检查器面板Inspector tab</strong>的一些浮点值会输入到着色器的<strong>表面函数surface function</strong>中去。如果你想了解属性的更多信息，可以去看<strong><a href="">第一章，创建你的第一个着色器</a></strong> 。</p><p>一旦我们获得了来自材质<strong>检查器面板Inspector</strong>这些浮点值后，我们就可以在着色器中利用它们来对UV值进行偏移修改。</p><p>但是在此之前，我们首先把UV值保存在了一个叫做<strong>scrolledUV</strong>的独立变量中。这个变量需要是<strong>float2/fixed2</strong>类型，因为从<strong>Input</strong>结构传过来给我们的UV值是下面这样的：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Input</span>
<span class="p">{</span>
	<span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>一旦拿到了游戏网格的UV，我们就可以用我们的滚动速度和着色器内建的<strong>_Time</strong>变量偏移修改它们。这个内建的变量会返回<strong>float4</strong>类型的变量，也就是说这个变量的每一个部分都包含了不同的时间值，这个时间来自游戏内的时间。</p><p>关于这个独特的时间值，可以通过下面的链接查看它的完整描述：</p><p><a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a></p><p>这个<strong>_Time</strong>变量根据Unity的游戏时钟增量过的浮点值。所以我们能使用这个值，根据UV的两个方向移动我们的UV，并且根据我们的滚动速度对这个时间进行缩放：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// Create variables that store the individual x and y</span>
<span class="c1">// components for the uv's scaled by time</span>
<span class="k">fixed</span> <span class="n">xScrollValue</span> <span class="p">=</span> <span class="n">_ScrollXSpeed</span> <span class="p">*</span> <span class="n">_Time</span><span class="p">;</span>
<span class="k">fixed</span> <span class="n">yScrollValue</span> <span class="p">=</span> <span class="n">_ScrollYSpeed</span> <span class="p">*</span> <span class="n">_Time</span><span class="p">;</span>
</pre></table></code></div></div><p>通过时间算出了正确的UV偏移量，接着就可以添加新的偏移量的值到原来的UV位置中去。这也是我们为什么在下一行要用<strong>+=</strong>操作符的原因。我们想要拿到原来的UV位置，对这个位置加上新的偏移量，然后再把这个值传给<strong>tex2D()</strong>这个函数作为贴图的新UV。这个过程让我们创建了贴图在游戏对象表面移动的效果。 表面上来看，我们的效果好像在移动贴图，但实际上我们是在修改UV而已：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">scrolledUV</span> <span class="p">+=</span> <span class="nf">fixed2</span><span class="p">(</span><span class="n">xScrollValue</span><span class="p">,</span> <span class="n">yScrollValue</span><span class="p">);</span>
<span class="n">half4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">scrolledUV</span><span class="p">);</span>
</pre></table></code></div></div></ul><hr /><p><span id="NM"></span></p><h2 id="法线贴图">法线贴图</h2><p>3D模型的每一个三角面都有一个<strong>朝向facing direction</strong>，这个朝向就是它向前的指向。它通常用一个垂直并且放置在三角面正中心的一个箭头来表示。这个朝向对于光在表面反射中来说非常的重要。如果相邻的两个三角面朝向不同的方向，那么它们对光的反射也会朝向不同的角度，也就是在着色器中它们的处理方式会不一样。对于曲面物体来说，这里有个疑问：很显然这些拥有曲面的几何体仍然是由平面三角形构成的，那光线改如何处理？</p><p>为了避免这个问题，对应三角面的光的反射计算方式此时不根据它的朝向计算，而是根据它的<strong>法线方向normal direction</strong>方向计算。前面<strong><em>向着色器添加纹理</em></strong>那个知识点讲到，顶点是保存有数据的。法线方向信息也是继UV信息之后，保存在顶点中最有用的信息。这是一个单位长度的向量，并且它表示了顶点的朝向。不考虑朝向的话，那么三角面内的每一个顶点都有它自己的法线方向，只不过这个法线方向是一个存储在顶点中的线性插值。这给了我们用低模模拟高模的能力。下面示例图展示了同一个几何形状在不同的顶点插值密度下的表现。在左边，法线垂直于由顶点表示的面；很明显每个面之间有明显的的割裂感。再看看最右边的几何体，它的法线是通过他的面线性插值得到的，可以看出来的是，尽管它的表面看起来还是很粗糙，但是光线的反射看起来却似乎很光滑。很容易看出来尽管这三个物体的几何体都相同，但是它们的光线反射却不一样。尽管都是由平面三角形构成，但是右边物体的光线反射似乎看起来像曲面反射。</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram16.jpg" /></div><p>一个有着粗糙的边的光滑物体很明显的表示单位顶点的法线肯定进行了线性插值。如果我们对保存在每个顶点的法线按其方向进行绘制，我们就能够看到它们，正如下图所展示的那样。你应该注意的是每个三角形仅有三条法线，但是相连的三角形有相同的顶点，会看到不止有一条法线从中绘制出来。</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram17.jpg" /></div><p>法线贴图在计算3D模型的法线技术中脱颖而出。跟纹理贴图类似，法线方向也可以用一张额外的纹理表示，我们把它们叫做<strong>法线贴图normal map</strong>或者<strong>凹凸贴图bump map</strong>。 法线贴图通常是一张RGB图片，里面的RGB通常分别用来表示法线方向中的X，Y，Z方向。现在有很多种技术方法来创建一张法线贴图。比如这些应用程序，<strong>CrazyBump</strong>(<a href="http://www.crazybump.com/">http://www.crazybump.com/</a>)跟<strong>NDO Painter</strong>(<a href="http://www.crazybump.com/">http://www.crazybump.com/</a>)可以把2D数据转换成法线数据。其他的应用程序比如<strong>Zbrush 4R7</strong>(<a href="http://www.pixologic.com/">http://www.pixologic.com/</a>)和<strong>AUTODESK</strong>(<a href="http://usa.autodesk.com">http://usa.autodesk.com</a>)可以把雕刻数据转换成法线贴图。如何创建法线贴图完全超出了本书的范畴，但上面的内容对你了解相关相应的知识还是有好处的。</p><p>在Unity中向着色器添加法线的过程很简单，因为在表面着色器中有着<strong>UnpackNormals()</strong>这样的方法给你调用。就让我们看看这是怎样的一个过程。</p><hr /><ul><li><p><strong>始前准备</strong><span id="NM_getting_ready"></span></p><p>分别创建一个新的材质和着色器，并且把它设置到<strong>场景视图Scene view</strong>中的游戏对象中去。这样的话，我们的项目非常简单，好让我们仅仅是观察法线贴图这项技术。</p><p>这个知识点中你需要一张法线贴图，但是我们这本书附带的Unity工程中包含了一张。[当然，你也可以从我这里把这张图片下载下来，如下图]</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram18.jpg" /></div></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="NM_how_to_do_it"></span></p><p>下面就是创建法线贴图着色器的步骤了：</p><ol><li><p>让我们设置好我们的属性块，从而可以获得颜色和贴图：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Properties</span>
<span class="p">{</span>
	<span class="nf">_MainTint</span> <span class="p">(</span><span class="s">"Diffuse Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
	<span class="nf">_NormalTex</span> <span class="p">(</span><span class="s">"Normal Map"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"bump"</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>注意</strong></p><p>因为用的是<strong>bump</strong>来初始化了属性的贴图类型，这等于是告诉了Unity<strong>_NormalTex</strong>包含了法线贴图。如果这个贴图没有被设置， 那么会默认给它设置一张灰色的贴图。颜色值会用<strong>(0.5,0.5,0.5,1)</strong>，然后看不出一点凹凸感。</p><li><p>在<strong>CGPROGRAM</strong>下面的<strong>SubShader{}</strong>块中声明下面两个变量，让这两个变量跟属性块中的两个属性关联起来：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">CPROGRAM</span>
<span class="cp">#pragma surface surf Lambert
</span><span class="c1">// Link the property to the CG program</span>
<span class="n">sampler2D</span> <span class="n">_NormalTex</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_MainTint</span><span class="p">;</span>
</pre></table></code></div></div><li><p>我们需要修改<strong>输入结构体Input struct</strong>的名字，从而让我们可以让我们通过模型的UV来访问法线贴图：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Make sure you get the UVs for the texture in the struct</span>
<span class="k">struct</span> <span class="nc">Input</span>
<span class="p">{</span>
	<span class="n">float2</span> <span class="n">uv_NormalTex</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>最后，我们通过内建的<strong>UnpackNormal()</strong>函数从法线贴图中提取出我们需要的法线信息。接着，你只要把这些新的法线应用到表面着色器的输出上即可：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Get the normal data out of the normal map texture</span>
<span class="c1">// using the UnpackNormal function</span>
<span class="n">float3</span> <span class="n">normalMap</span> <span class="p">=</span> <span class="nf">UnpackNormal</span><span class="p">(</span><span class="nf">tex2D</span><span class="p">(</span><span class="n">_NormalTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_NormalTex</span><span class="p">));</span>
<span class="c1">// Apply the new normal to the lighting model</span>
<span class="n">o</span><span class="p">.</span><span class="n">Normal</span> <span class="p">=</span> <span class="n">normalMap</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</pre></table></code></div></div></ol><p>下图展示了我们的法线贴图着色器的最终效果：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram19.jpg" /></div><p><strong>注意</strong></p><p>着色器可以同时拥有纹理贴图和法线贴图。用UV数据同时来关联这两种贴图并不少见。然而，也可以在特有的顶点数据(UV2)中提供第二个UV的参数设置来设置法线贴图。</p></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="NM_how_it_works"></span></p><p>法线贴图效果背后的数学原理完全超出了本书的范畴，不过Unity已经为我们做了这一切。由于Unity为我们创建了各种方法所以我们不用一遍又一遍的做重复劳动。这也是为什么说表面着色器是编写着色器代码的高效方式的另一个原因。</p><p>如果你在Unity的安装文件夹下的<strong>Data</strong>文件夹下的<strong>UnityCG.cginc</strong>文件中查找的话，你可以找到<strong>UnpackNormal()</strong>这个函数的定义。当你在表面着色器声明这个函数的时候，Unity会通过提供给它的法线贴图进行处理并且返回给你正确类型的数据，这样你就可以逐像素光照函数中使用它们。这为你节约了大量的时间！当对一张纹理[法线贴图]进行采样时，你可以获得从0到1取值范围的RGB值；然而，法线方向向量的取值范围确实-1到1。通过<strong>UnpackNormal()</strong>函数就可以给法线方向向量获取合理的值。</p><p>当你通过<strong>UnpackNormal()</strong>函数对法线贴图进行了处理后，你把处理后的结果返回给了<strong>SurfaceOutput</strong>结构体，这样你才能在光照函数中使用它们。这是通过着色器中<strong>o.Normal = normalMap.rgb;</strong>这条语句实现的。我们会在<strong><a href="">第三章</a>理解光照模型</strong>这一章中会看，法线究竟是怎么用于计算每一个像素点最终颜色的。</p></ul><hr /><ul><li><p><strong>相关补充</strong><span id="NM_there_is_more"></span></p><p>你也可以在你的法线贴图着色器中添加一些控制从而可以让用户修改法线贴图的强度。这一点很容易通过改变法线贴图变量的<strong>x</strong>和<strong>y</strong>元素然后把它们全部返回来办到。在法线贴图着色器中的属性块中添加另一个属性，名称为<strong>NormalMapIntensity</strong>：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_NormalMapIntensity</span><span class="p">(</span><span class="s">"Normal intensity"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">1</span>
</pre></table></code></div></div><p>把解包出来的法线贴图数据的<strong>x</strong>和<strong>y</strong>都乘以这个属性然后把这个得到的新的值返回给法线贴图变量：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">fixed3</span> <span class="n">n</span> <span class="p">=</span> <span class="nf">UnpackNormal</span><span class="p">(</span><span class="nf">tex2D</span><span class="p">(</span><span class="n">_BumpTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_</span> <span class="n">uv_MainTex</span><span class="p">)).</span><span class="n">rgb</span><span class="p">;</span>
<span class="n">n</span><span class="p">.</span><span class="n">x</span> <span class="p">*=</span> <span class="n">_NormalMapIntensity</span><span class="p">;</span>
<span class="n">n</span><span class="p">.</span><span class="n">y</span> <span class="p">*=</span> <span class="n">_NormalMapIntensity</span><span class="p">;</span>
<span class="n">o</span><span class="p">.</span><span class="n">Normal</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</pre></table></code></div></div><p><strong>注意</strong></p><p>法线向量的长度最好是等于1。当它们乘以<strong>_NormalMapIntensity</strong>后会改变它们的长度，所以对它进行标准化[归一化]是很有必要的。</p><p>现在你可以让使用者在材质的<strong>检查器面板Inspector tab</strong>修改法线贴图的强度了。 下图为我们展示了法线贴图在不同强度参数下的不同表现：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram20.jpg" /></div></ul><hr /><p><span id="CATM"></span></p><h2 id="创建一个带透明度的材质">创建一个带透明度的材质</h2><p>到目前为止我们所看到的着色器似乎都有一个共同点——它们都用于了固体材质。如果你想要的提升你的游戏的视觉效果，那么带透明度的材质通常是一个好的开始。它们用途广泛，从火焰效果到窗户的玻璃都会用到它们。但稍微麻烦的是，它们用起来要复杂一点点。在渲染固体模型之前，Unity会根据它们离摄像机的距离(<strong>这个叫Z ordering</strong>)进行排序，并且跳过渲染所有背朝摄像机的三角面(<strong>这个是剔除技术culling</strong>)。当渲染带透明度的几何物体时，这些含有两个面的几何物体就会产生问题。这次的知识点将会为你展示：当我们创建有透明度的表面着色器时，我们如何解决这个过程中产生的这些问题。我们在<strong><a href="">第六章</a>,片元着色器和通道提取</strong>我们还会着重回顾这个话题，真实渲染中的玻璃和水体着色器都会涉及到。</p><hr /><ul><li><p><strong>始前准备</strong><span id="CATM_getting_ready"></span></p><p>这个知识点需要一个新的着色器，我们就叫它<strong>Transparent</strong>吧。同时也需要一个新的材质，这样才能把着色器应用于游戏物体。因为这个物体需要成为一个透明的玻璃窗，那么我们最好用Unity中的<strong>quad</strong>或者<strong>plane</strong>来做。我们当然也需要一些不透明的其他游戏对象来对比测试效果。在这个例子中，我们会使用一张PNG图片作为玻璃纹理。这张图片的alpha通道将会用于控制玻璃的透明度。这样的PNG图片大家自行自作，软件不限。但是需要遵守下面的这些步骤：</p><ol><li><p>找一张要用于你窗户玻璃的图片。</p><li><p>用照片编辑软件打开这样图片，比如<strong>GIMP</strong>或者<strong>Photoshop</strong>。</p><li><p>选择图片中你想要变成半透明的部分。</p><li><p>在这张图片上创建一个空白(<strong>full opacity</strong>[抱歉我不懂PS，不知道这个参数的含义])图层</p><li><p>选择上一步创建的图片，以黑色来填充这个图层。</p><li><p>保存图片然后导入到Unity中。</p></ol><p>这个知识点中，我们用来试验的图片是一张来自<strong>圣斯德望主教座堂</strong> <strong><em>Meaux Cathedral in France(<a href="https://en.wikipedia.org/wiki/Stained_glass">https://en.wikipedia.org/wiki/Stained_glass</a>)</em></strong>的花窗玻璃。</p><p>如果遵循了上面的图片制作步骤，那么你也会获得如下类似的一张图片（<strong>RGB</strong>通道在左图，<strong>A</strong>通道在右图）：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram21.png" /></div></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="CATM_how_to_do_it"></span></p><p>正如我们前面提醒的，我们在使用透明度着色器时需要注意几个方面：</p><ol><li><p>在着色器的<strong>SubShader{}</strong>代码块中，添加下面的<strong>标签</strong>告知着色器这是用于透明度的：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">Tags</span>
<span class="p">{</span>
	<span class="s">"Queue"</span> <span class="p">=</span> <span class="s">"Transparent"</span>
	<span class="s">"IgnoreProjector"</span> <span class="p">=</span> <span class="s">"True"</span>
	<span class="s">"RenderType"</span> <span class="p">=</span> <span class="s">"Transparent"</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>由于这个着色器是为2D 材料设计的，所以确保你的模型的背面不会被绘制，通过添加下面的这个代码：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Cull</span> <span class="n">Back</span>
</pre></table></code></div></div><li><p>告诉着色器这个材料是半透明的并且需要跟屏幕中绘制的什么内容混合：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma surface surf Standard alpha:fade
</span></pre></table></code></div></div><li><p>使用这个表面着色器来决定玻璃的颜色和透明度：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">surf</span><span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">float4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="p">*</span> <span class="n">_Color</span><span class="p">;</span>
	<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
	<span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ol></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CATM_how_it_works"></span></p><p>这个着色器中介绍了几个新的概念。首先，<strong>标签Tags</strong>用于添加一些关于游戏对象是如何渲染的信息。但是这次这里真正让人感兴趣的是<strong>Queue</strong>。Unity默认会根据物体距离摄像机的距离来对游戏对象进行排序。所以当一个物体距离摄像机越近，那么它就会比所有离摄像机更远的物体先绘制。在大多数情况下，它对游戏来说都没有问题，但是有些情况下你可能想要自己控制游戏场景中物体的渲染顺序。Unity已经有提供给我们一些默认的渲染队列，每一个队列都有一个单独的值好让Unity按照这个顺序在屏幕中绘制游戏物体。这些内建的渲染队列分别叫做<strong>[这些参数就不翻译了]</strong> <strong>Background</strong>，<strong>Geometry</strong>，<strong>AlphaTest</strong>，<strong>Transparent</strong>， 和 <strong>Overlay</strong>。 这些队列并不是随意创建的；创造它们是为了让我们能更容易的编写着色器代码和跟实时渲染进行交互。下表描述了每一个不同的渲染队列的作用：</p><div class="table-wrapper"><table><thead><tr><th>渲染队列<th style="text-align: left">队列描述<th>渲染队列值<tbody><tr><td>Background<td style="text-align: left">这个渲染队列最先渲染。它被用于天空盒等等。<td>1000<tr><td>Geometry<td style="text-align: left">这个是默认的渲染队列。大多数游戏对象都用这个 。不透明物体使用这个队列。<td>2000<tr><td>AlphaTest<td style="text-align: left">Alpha-tested几何体使用这个队列。跟 Geometry队列不同的是在所有的固态物体都被渲染的情况下，它在渲染alpha-tested游戏对象上效率更高。<td>2450<tr><td>Transparent<td style="text-align: left">这个队列在Geometry队列和AlphaTest队列之后，并且是由后向前渲染顺序。任何的alpha渲染（着色器不会写入深度buffer）都应该在这个队列，比如玻璃效果和例子效果。<td>3000<tr><td>Overlay<td style="text-align: left">这个渲染队列是为叠加效果准备的。所有在最后渲染的东西都用此队列，比如镜头光晕。<td>4000</table></div><p>所以，一旦你知道你的游戏对象属于哪个渲染队列后，那么你就可以给它设置渲染队列。我们这次的着色器用到了<strong>Transparent</strong>队列，所以我们在代码中用到了<strong>Tags{“Queue”=”Trasparent”}.</strong>这样的标签。</p><p><strong>注意</strong></p><p>事实上<strong>Transparent</strong>队列在<strong>Geometry</strong>队列后渲染并不是意味着玻璃会出现在其他所有固态物体的上面。Unity会在最后再绘制玻璃，同时也并不会渲染任何一个被其他物体遮住部分的游戏对象的像素点。这样的控制可以用一种叫<strong>ZBuffering</strong>的技术实现。更多关于模型是如何被渲染的资料可以在下面的链接找到：</p><p><a href="http://docs.unity3d.com/Manual/SLCullAndDepth.html">http://docs.unity3d.com/Manual/SLCullAndDepth.html</a>。</p><p>标签<strong>IgnoreProjector</strong>可以让这个游戏对象不受Unity的投影的影响。最后，<strong>RenderType</strong>扮演了一个着色器替换的角色，这个话题在 <strong><a href="">第九章</a>，游戏和屏幕特效</strong>中会简略的谈一下这个话题。</p><p>最后一个要介绍的概念就是<strong>alpha:fade</strong>。这表示这个材质中的所有像素点会根据它们的alpha值决定必须要先跟屏幕中的什么物体混合渲染。如果没有用这个指明的话，像素会按照正确的顺序绘制，但是它们不会有任何的透明度。</p></ul><hr /><p><span id="CAHS"></span></p><h2 id="创建一个有全息效果的着色器">创建一个有全息效果的着色器</h2><p>近些年来太空主题的发行的越来越多。科幻游戏中很重要的一个部分就是在游戏中集合了来自未来的各种技术。全息投影就是其中的典型代表。全息投影尽管有很多种形式，但是通常用一种半透明，看起来很薄的投影来呈现。这次的这个知识点将会向你展示如何创建一个这样的着色器来模拟这样的效果。我们首先想到：要创建一个优秀的全息投影特效，你需要能够添加噪音，扫描动画和和震动。下图就展示了一个全息投影效果的列子：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram22.png" /></div><hr /><ul><li><p><strong>始前准备</strong><span id="CAHS_getting_ready"></span></p><p>正如全息投影效果展示的知识物体的轮廓，所以我们可以把我们的这个着色器命名成<strong>Silhouette</strong>[轮廓的意思]。把它跟材质关联起来并且把它应用到你的3D模型中去。</p></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="CAHS_how_to_do_it"></span></p><p>根据下面的步骤可以将我们的当前的着色器修改为有全息投影效果的着色器：</p><ol><li><p>在着色器中添加下面的属性：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_DotProduct</span><span class="p">(</span><span class="s">"Rim effect"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.25</span>
</pre></table></code></div></div><li><p>并且添加跟属性对应的变量到<strong>CGPROGRAM</strong>块中去：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">_DotProduct</span><span class="p">;</span>
</pre></table></code></div></div><li><p>因为这个材质是有透明度的，所以需要添加下面的标签：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">Tags</span>
<span class="p">{</span>
	<span class="s">"Queue"</span> <span class="p">=</span> <span class="s">"Transparent"</span>
	<span class="s">"IgnoreProjector"</span> <span class="p">=</span> <span class="s">"True"</span>
	<span class="s">"RenderType"</span> <span class="p">=</span> <span class="s">"Transparent"</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>注意</strong></p><p>根据你将会使用的游戏对象类型，你可能想要它的背面也能看到。如果是这种情况，那么我们就需要在代码中添加<strong>Cull Off</strong>，从而让模型的背面不会被剔除。</p><li><p>这个着色器并不会尝试去模拟真实世界的材质，所以这里就没有必要再使用PBR关照模型了。我们将会用性能消耗更少的<strong>Lambertian 反射</strong>来代替它。另外，我们应该使用<strong>nolighting</strong>来关闭所有的光线并且用<strong>alpha:fade</strong>来告诉Cg我们得着色器是一个有透明度的着色器：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma surface surf Lambert alpha:fade nolighting
</span></pre></table></code></div></div><li><p>修改输入结构体从而能让Unity输入当前的视口方向和世界的法线方向：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Input</span>
<span class="p">{</span>
	<span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
	<span class="n">float3</span> <span class="n">worldNormal</span><span class="p">;</span>
	<span class="n">float3</span> <span class="n">viewDir</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><li><p>修改你的<strong>表面函数surface function</strong>成下面的样子。请记住因为这个着色器使用<strong>Lambertian</strong>反射作为光照函数，所以表面输出结构体的名字也要相应改成<strong>SurfaeOutput</strong>，这是<strong>SurfaceOutputStandard</strong>类型的实例。</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">surf</span><span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">float4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="p">*</span> <span class="n">_Color</span><span class="p">;</span>
	<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">border</span> <span class="p">=</span> <span class="m">1</span> <span class="p">-</span> <span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">IN</span><span class="p">.</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">worldNormal</span><span class="p">)));</span>
	<span class="kt">float</span> <span class="n">alpha</span> <span class="p">=</span> <span class="p">(</span><span class="n">border</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">-</span> <span class="n">_DotProduct</span><span class="p">)</span> <span class="p">+</span> <span class="n">_DotProduct</span><span class="p">);</span>
	<span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">*</span> <span class="n">alpha</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>现在你可以使用<strong>Rim effect</strong>这个滑动条来选择全息投影效果的强度。</p></ol></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CAHS_how_it_works"></span></p><p>正如前面提到的，这个着色器仅仅是展示了物体的轮廓。如果我们从不同的角度看这个物体，它的轮廓也会改变。从几何学的角度上讲，模型的所有边都包含在<strong>法线方向normal direction</strong>垂直于<strong>视口方向view direction</strong>的三角形上。<strong>输入结构体Input structure</strong>声明了这些变量，分别是<strong>worldNormal</strong>和<strong>viewDir</strong>这两个参数。</p><p>要知道两个向量是否垂直可以用<strong>点积dot product</strong>进行判断。她是一个操作符，接收两个向量作为参数，如果这两个向量垂直，会返回零。我们使用参数<strong>DotProduct</strong>来控制点积趋近于零的程度从而控制那些三角形应该完全消失。</p><p>这个着色器的另一方面，我们用了<strong>_DotProduct(不可见)</strong>来确定模型的边（完全可见）和角度之间消失的力度。这个线性插值是通过下面的代码实现的：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">alpha</span> <span class="p">=</span> <span class="p">(</span><span class="n">border</span> <span class="p">*</span> <span class="p">(</span><span class="m">1</span> <span class="p">-</span> <span class="n">_DotProduct</span><span class="p">)</span> <span class="p">+</span> <span class="n">_DotProduct</span><span class="p">);</span>
</pre></table></code></div></div><p>最后，贴图原来的alpha值乘以一个计算好的系数后，我们获得了最终的样子。</p></ul><hr /><ul><li><p><strong>相关补充</strong><span id="CAHS_there_is_more"></span></p><p>这种技术非常的简单并且性能消耗相对较低。不过这种着色器还可以用于其他的各种各样的特效，比如下面的这些：</p><ul><li>科幻游戏中包裹星球的浅色大气层<li>被选中的游戏物体的边或者当前鼠标下的物体<li>鬼魂或者幽灵<li>引擎冒出的烟<li>爆炸的冲击波<li>太空战舰被攻击时的防护罩</ul></ul><hr /><ul><li><p><strong>额外内容</strong><span id="CAHS_see_also"></span></p><p>在反射计算中向量的<strong>点积dot product</strong>扮演着非常重要的角色。我们在 <strong><a href="">第三章</a>，理解光照模型</strong> 这个章节中会详细的介绍它是如何工作的以及为什么会广泛的用于很多的着色器中。</p></ul><hr /><p><span id="PABT"></span></p><h2 id="纹理的压缩和混合">纹理的压缩和混合</h2><p>纹理的作用并不仅仅只是我们通常认为的保存加载的数据或者像素颜色，同时还有像素点在<strong>x</strong>和<strong>y</strong>方向以及RGBA通道的各种设置。我们能把多张图片压缩进一张单独的RGBA纹理中并且使用它们各自的R，G，B和A元素，因为我们可以在着色器中把它们各自纹理中的这些元素分别解压出来。</p><p>将各自的灰度图压缩进一张单独的RGBA纹理的结果可以通过下图看出来：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram23.png" /></div><p>为什么说这会有用呢？在你的应用程序实际消耗的大部分中内存当中，贴图占了很大的一部分。所以如果你想要减少应用程序的大小的话，我们能在着色器中查看所有使用的图片并且想想我们是否能将这些纹理合并到一张单独的纹理中。</p><p>任何灰度的纹理都可以压缩进另一张有RGBA通道的纹理。第一次听起来可能有点怪怪的，但我们接下来会用这个知识点来演示纹理压缩的用法并且在我们的着色器中使用这张压缩过的纹理。</p><p>举其中一个纹理压缩用法例子，比如你想把一套纹理[有好几张]混合进一张单独的纹理中。这在地形类着色器中很常见，在我们的例子中，我们会用一些排好序的控制纹理或者压缩过的纹理，很好的混合进另一张纹理中。这个知识点会讲到这个技术的，同时还会告诉你如何开始编写好这样一个混合四张纹理的着色器。</p><hr /><ul><li><p><strong>始前准备</strong><span id="PABT_getting_ready"></span></p><p>在我们Unity的着色器文件夹中创建一个新的着色器同时创建一个新的材质与之对应。这两者的命名怎么方便怎么来，不过尽量保证组织和引用方便吧。</p><p>建好着色器和材质后，再创建一个新的场景，好给后面做测试。</p><p>收集好四张你打算混合在一起的纹理。我们直接用它们展示这几张纹理是如何放到物体表面的。</p><p>我们可以用一些非常复杂的混合纹理在地形网格上创建一个非常真实的地形分布纹理，如下所示：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram24.png" /></div></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="PABT_how_to_do_it"></span></p><p>我们通过下面代码来学习如何使用压缩纹理。</p><ol><li><p>我们在着色器的<strong>属性Properties</strong>块中添加一些属性。我们需要5个<strong>sampler2D</strong>类型的游戏对象或纹理，2个颜色属性：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">Properties</span>
<span class="p">{</span><span class="n">_</span>
   <span class="nf">MainTint</span> <span class="p">(</span><span class="s">"Diffuse Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
   <span class="c1">//Add the properties below so we can input all of our textures</span>
   <span class="nf">_ColorA</span> <span class="p">(</span><span class="s">"Terrain Color A"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
   <span class="nf">_ColorB</span> <span class="p">(</span><span class="s">"Terrain Color B"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
   <span class="nf">_RTexture</span> <span class="p">(</span><span class="s">"Red Channel Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">""</span><span class="p">{}</span>
   <span class="nf">_GTexture</span> <span class="p">(</span><span class="s">"Green Channel Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">""</span><span class="p">{}</span>
   <span class="nf">_BTexture</span> <span class="p">(</span><span class="s">"Blue Channel Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">""</span><span class="p">{}</span>
   <span class="nf">_ATexture</span> <span class="p">(</span><span class="s">"Alpha Channel Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">""</span><span class="p">{}</span>
   <span class="nf">_BlendTex</span> <span class="p">(</span><span class="s">"Blend Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">""</span><span class="p">{}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>接下来我们在<strong>SubShader{}</strong>块中创建一些变量，记住要跟上一步的属性块对应。</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre> <span class="n">CGPROGRAM</span>
<span class="cp">#pragma surface surf Lambert
</span> <span class="n">float4</span> <span class="n">_MainTint</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_ColorA</span><span class="p">;</span>
 <span class="n">float4</span> <span class="n">_ColorB</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_RTexture</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_GTexture</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_BTexture</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_BlendTex</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_ATexture</span><span class="p">;</span>
</pre></table></code></div></div><li><p>我们现在获得了纹理属性后把它们传递给<strong>SubShader{}</strong>函数。为了能够让使用者可以控制每个纹理的截取比例，我们需要修改<strong>输入结构体Input struct</strong>。这样我们就可以使用每个纹理的截取和偏移量等参数:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Input</span>
<span class="p">{</span>
   <span class="n">float2</span> <span class="n">uv_RTexture</span><span class="p">;</span>
   <span class="n">float2</span> <span class="n">uv_GTexture</span><span class="p">;</span>
   <span class="n">float2</span> <span class="n">uv_BTexture</span><span class="p">;</span>
   <span class="n">float2</span> <span class="n">uv_ATexture</span><span class="p">;</span>
   <span class="n">float2</span> <span class="n">uv_BlendTex</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>注意[译者添加]</strong></p><p>如果遇到<strong>Too many texture interpolators would be used for ForwardBase pass</strong>错误，因为是Input中定义的材质uv变量太多了，当前版本的shader model不支持造成。此时将shader model改为更高的版本可以解决。如果你的#pragma target 3.0不支持3个材质，可以改为#pragma target 4.0试试吧。</p><p>如果非要用#pragma target 3.0，只能通过共用uv_MainTex或者使用屏幕坐标来解决了。</p><li><p>然后再<strong>surf()</strong>函数里，为了便于理解，我们把纹理的信息都分别保存到它们各自的变量中：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">//Get the pixel data from the blend texture</span>
<span class="c1">//we need a float 4 here because the texture//will return R,G,B,and A or X,Y,Z, and W</span>
<span class="n">float4</span> <span class="n">blendData</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_BlendTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_BlendTex</span><span class="p">);</span>
<span class="c1">//Get the data from the textures we want to blend</span>
<span class="n">float4</span> <span class="n">rTexData</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_RTexture</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_RTexture</span><span class="p">);</span>
<span class="n">float4</span> <span class="n">gTexData</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_GTexture</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_GTexture</span><span class="p">);</span>
<span class="n">float4</span> <span class="n">bTexData</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_BTexture</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_BTexture</span><span class="p">);</span>
<span class="n">float4</span> <span class="n">aTexData</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_ATexture</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_ATexture</span><span class="p">);</span>
</pre></table></code></div></div><li><p>我们用<strong>lerp()</strong>函数把每一个纹理混合到一起。这个函数接收三个参数，<strong>lerp(value : a, value : b, blend: c)</strong>。<strong>lerp()</strong>函数用前面两个参数的纹理跟最后一个浮点型参数进行混合：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">//No we need to contruct a new RGBA value and add all</span>
<span class="c1">//the different blended texture back together</span>
<span class="n">float4</span> <span class="n">finalColor</span><span class="p">;</span>
<span class="n">finalColor</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">rTexData</span><span class="p">,</span> <span class="n">gTexData</span><span class="p">,</span> <span class="n">blendData</span><span class="p">.</span><span class="n">g</span><span class="p">);</span>
<span class="n">finalColor</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">finalColor</span><span class="p">,</span> <span class="n">bTexData</span><span class="p">,</span> <span class="n">blendData</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
<span class="n">finalColor</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">finalColor</span><span class="p">,</span> <span class="n">aTexData</span><span class="p">,</span> <span class="n">blendData</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="n">finalColor</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="m">1.0</span><span class="p">;</span>
</pre></table></code></div></div><li><p>最后，我们把混合后的纹理乘以颜色并且用红色通道来决定到底该用这两个地形颜色的哪一个：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">//Add on our terrain tinting colors</span>
<span class="n">float4</span> <span class="n">terrainLayers</span> <span class="p">=</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">_ColorA</span><span class="p">,</span> <span class="n">_ColorB</span><span class="p">,</span> <span class="n">blendData</span><span class="p">.</span><span class="n">r</span><span class="p">);</span>
<span class="n">finalColor</span> <span class="p">*=</span> <span class="n">terrainLayers</span><span class="p">;</span>
<span class="n">finalColor</span> <span class="p">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="n">finalColor</span><span class="p">);</span>
<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">finalColor</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">_MainTint</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">finalColor</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</pre></table></code></div></div></ol><p>下图展示了我们通过混合四张地形纹理贴图，并且创建一个地形的技术：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram25.png" /></div></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="PABT_how_it_works"></span></p><p>这里代码量好像有点多，但是混合后面的概念是比较简单的。为了展示混合的技术，我们使用了来自CgFX标准库中的内建函数<strong>lerp()</strong>。这个函数允许我们以第三个参数作为混合量，获得一个介于第一个参数和第二个参数之间的数：</p><div class="table-wrapper"><table><thead><tr><th>函数<th>描述<tbody><tr><td><strong>lerp(a,b,f)</strong><td>这里其实是线性插值：<br /> (1 – f )* a + b * f <br />这里的<strong>a</strong>和<strong>b</strong>需要时向量或者标量。但是<strong>f</strong>只能是跟<strong>a</strong>和<strong>b</strong>类型一样的标量或者向量。</table></div><p>我们举例子来演示，比如我们想要获得一个介于1和2之间的中间值，我们此时可以给<strong>lerp()</strong>函数的第三个参数传一个0.5那么这个函数就会返回1.5。这刚好能满足我们混合纹理的需求，因为在RGBA纹理中的每一个通道的值都是一个浮点值，这些值得取值范围通常都是0到1。</p><p>在这个着色器中，我们都简单的从需要混合的纹理中，拿了一个通道的值，来控制用<strong>lerp()</strong>函数获得的颜色值，这些值最终在赋值给每一个像素点。比如我们用草的纹理和泥土的纹理，再加上我们混合纹理中的红色通道，把这些值分别传递给<strong>lerp()</strong>函数的第一，二，三个参数。这样我们就能获得地表中每一个像素正确混合后的颜色。</p><p>下图更直观的向我们展示了当我们使用<strong>lerp()</strong>函数时，到底发生了什么：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram26.png" /></div><p>着色器代码简单的使用了混合纹理的四个通道和所有的颜色纹理，最终创建了一个混合后的纹理。这个最终的纹理的颜色用于跟漫反射的光进行相乘的操作。</p><p>[这里找不到这个项目的代码，只能随机应变翻译，没有项目可以跑]</p></ul><hr /><p><span id="CCAYT"></span></p><h2 id="在地形的表面绘制一个圆">在地形的表面绘制一个圆</h2><p>在很多的RTS类型的游戏中，通过围绕被选中的单位绘制一个圆圈来表示距离（攻击范围，可移动距离，视野等等）。如果地面是平坦的，那么可以用通过对一张绘制有圆圈的矩形纹理进行缩放就能简单的做到。但是如果地面并不平坦，那么这个矩形的纹理就很有可能被高出的山丘或者其他几何物体遮住。接下来的知识点将展示如何编写一个着色器，让你可以在任何复杂的物体表面绘制一个圆圈[且不会被遮住]。如果你想对这个圆圈移动或者执行动画，那么我们就需要有着色器和C#代码才行。下图展示了用着色器在一个丘陵地形中绘制一个圆圈的例子：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram27.png" /></div><hr /><ul><li><p><strong>始前准备</strong><span id="CCAYT_getting_ready"></span></p><p>这里的着色器主要是用于地形的，对于其他的游戏对象不适用。所以我们首先要做的是在Unity中创建好一个地形。</p><ol><li><p>我们先分别建立一个着色器和材质，名字分别是<strong>RadiusShader</strong>和<strong>RadiusMaterial</strong>。</p><li><p>当你的角色物体准备好后；我们会绕着它绘制一个圆圈。</p><li><p>在Unity的菜单[这里的菜单操作我就不翻译了，翻译了感觉反而不好，怕翻译错了，大家找不到]，选择 <strong>GameObject | 3D Object | Terrain</strong> 来创建一个新的地形。</p><li><p>为地形创建一些几何面。你可以导入一个已存在的地形或者自己用地形工具画一个新的。(<strong>Raise/Lower Terrain</strong>, <strong>Paint Height</strong>, <strong>Smooth Height</strong> )[括号里面这些都是Unity地形编辑器中的工具]</p><li><p>地形是Unity中特殊的游戏对象，它表面的纹理映射方式跟传统的3D模型不一样。你不能通过在着色器定义一个<strong>_MainTex</strong>来提供纹理，因为在地形中需要直接由地形自己提供。这一步骤可以通过在地形编辑器中选择<strong>Paint Texture</strong> 然后点击<strong>Add Texture…:</strong></p></ol><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram28.png" /></div><ol><li>完成上面步骤后，纹理就设置好了。你必须修改地形的材质这样就可以在地形中使用我们提供的自定义的着色器。在 <strong>Terrain Settings</strong>中, 把<strong>Material</strong>一栏的属性改为<strong>Custom</strong>，接着把我们的<strong>Radius material</strong>材质拖拽到<strong>Custom Material</strong>栏上。</ol><p>接下来就要准备你自己的着色器了。</p></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="CCAYT_how_to_do_it"></span></p><p>让我们开始编辑着色器<strong>RadiusShader</strong> 的代码:</p><ol><li>在新的着色器中, 添加下面四个属性:<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nf">_Center</span><span class="p">(</span><span class="s">"Center"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">)</span>
<span class="nf">_Radius</span><span class="p">(</span><span class="s">"Radius"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="p">=</span> <span class="m">0.5</span>
<span class="nf">_RadiusColor</span><span class="p">(</span><span class="s">"Radius Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
<span class="nf">_RadiusWidth</span><span class="p">(</span><span class="s">"Radius Width"</span><span class="p">,</span> <span class="n">Float</span><span class="p">)</span> <span class="p">=</span> <span class="m">2</span>
</pre></table></code></div></div><li>然后在<strong>CGPROGRAM</strong>块中添加它们各自的变量与之对应：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="n">float3</span> <span class="n">_Center</span><span class="p">;</span>
 <span class="kt">float</span> <span class="n">_Radius</span><span class="p">;</span>
 <span class="n">fixed4</span> <span class="n">_RadiusColor</span><span class="p">;</span>
 <span class="kt">float</span> <span class="n">_RadiusWidth</span><span class="p">;</span>
</pre></table></code></div></div><li>所以现在输入表面函数的数据不仅仅是纹理的UV数据了，还包括地形的中每一个点的位置(这个位置是基于世界坐标的)。 为了拿到这个参数我们需要修改<strong>输入结构体 Input struct</strong>，如下所示：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="k">struct</span> <span class="nc">Input</span>
 <span class="p">{</span>
   <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span> <span class="c1">// The UV of the terrain texture</span>
   <span class="n">float3</span> <span class="n">worldPos</span><span class="p">;</span> <span class="c1">// The in-world position</span>
 <span class="p">};</span>
</pre></table></code></div></div><li>最后我们在表面函数中使用这个参数：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> <span class="k">void</span> <span class="nf">surf</span><span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="kt">float</span> <span class="n">d</span> <span class="p">=</span> <span class="nf">distance</span><span class="p">(</span><span class="n">_Center</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="p">&gt;</span> <span class="n">_Radius</span> <span class="p">&amp;&amp;</span> <span class="n">d</span> <span class="p">&lt;</span> <span class="n">_Radius</span> <span class="p">+</span> <span class="n">_RadiusWidth</span><span class="p">)</span>
     <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">_RadiusColor</span><span class="p">;</span>
   <span class="k">else</span>
     <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
 <span class="p">}</span>  
</pre></table></code></div></div></ol><p>通过上面的步骤，你就可以在地形中绘制一个圆。你可以通过材质的<strong>检查器面板Inspector tab</strong>去改变这个圆的位置，半径和颜色。</p><li><p><strong>在表面移动这个圆</strong><span id="CCAYT_move_the_circle"></span></p><p>如果你想让圆跟着你的角色移动，那就还需要一些额外的工作：</p><ol><li>创建一个叫<strong>Radius</strong>的C#脚本。<li>在脚本中添加下面这些属性：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Material</span> <span class="n">radiusMaterial</span><span class="p">;</span>
<span class="k">public</span> <span class="kt">float</span> <span class="n">radius</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Color</span> <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">;</span>
</pre></table></code></div></div><li>在<strong>Update()</strong>方法中，添加下面这些代码：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">radiusMaterial</span><span class="p">.</span><span class="nf">SetVector</span><span class="p">(</span><span class="s">"_Center"</span><span class="p">,</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
<span class="n">radiusMaterial</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"_Radius"</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>
<span class="n">radiusMaterial</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_RadiusColor"</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</pre></table></code></div></div><li><p>然后把这个脚本挂在到你的角色身上。</p><li>最后把<strong>Radius material</strong>这个材质拖拽到C#脚本中的<strong>Radius Material</strong>中去[是在<strong>检查器面板Inspector tab</strong>中]。</ol><p>现在你可以移动你的角色，并且这个圆能很好的跟随玩家。并且修改脚本中的半径也能修改圆圈的半径大小。</p></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CCAYT_how_it_works"></span></p><p>绘制这个圆的相关参数是中心点，半径和颜色。它们分别可以在着色器中的<strong>_Center</strong>, <strong>_Radius</strong>, 和 <strong>_RadiusColor</strong>中获得。 通过在<strong>输入结构体Input structure</strong> 添加一个<strong>worldPos</strong>的变量，这等于是让Unity提供给我们像素点的位置，这些位置是用世界坐标来表示的。 这是编辑器中一个游戏对象的确切位置。 <strong>surf()</strong>函数是这个圆真正绘制的地方。 它会计算绘制点到中心点的距离，然后判断这个绘制点是否处于<strong>_Radius</strong> 和<strong>_Radius + _RadiusWidth</strong>之间；如果满足就使用对应的颜色。如果不是就不修改，跟我们以前遇到的情况一样对纹理贴图取样即可。</p></ul><hr /><p><span id="ULM"></span></p><h2 id="理解光照模型">理解光照模型</h2><p>在前面的那些章节中，我们介绍了表面着色器并且还理解了如何修改一些物理属性(比如<strong>Albedo</strong>和<strong>Specular</strong>)来模拟不同的材质。这些到底是如何工作的呢？每个表面着色器中最重要的部分一一<strong>光照模型lighting model</strong>。它的功能就是接受这些参数然后计算每一个像素点的最终着色。Unity通常会对开发者隐藏这部分，因为如果想要编写一个光照模型的话，你就必须要去理解光在物体表面是如何反射和折射的。这个章节中我们会毫无保留的向你展示光照模型是如何工作的，并且给你介绍一些你自己创建光照模型所需要的一些基础知识。</p><p>这一章中，我们会学习下面所列的知识点：</p><ul><li>创建一个自定义的漫反射光照模型<li>创建一个Toon风格的着色器<li>创建一个Phong类型类型的高光反射着色器<li>创建 BlinnPhong 类型的高光反射着色器<li>创建各向异性类型的高光反射着色器</ul><hr /><ul><li><p><strong>介绍</strong><span id="ULM_introduction"></span></p><p>想要模拟光的工作方式是一项非常具有挑战性的工作，同时也非常消耗计算资源。在之前的很早一段时间内，游戏中使用的都是一些非常简单的光照模型，效果看起来差到难以置信。尽管现在的3D游戏引擎已经使用了基于物理原理的渲染器，但是有些更简单的光照模型技术还是值得我们去探索的。但有时，我们不得不面对资源紧张的现实，没有办法在这些资源有限的设备上完整实现光照模型，比如我们的移动设备。所以你想在这上面实现自己的光照模型，那么你就很有必要了解这些简单的光照模型。</p></ul><hr /><p><span id="CCDLM"></span></p><h2 id="创建一个自定义的漫反射光照模型">创建一个自定义的漫反射光照模型</h2><p>如果你对Unity4很了解的话，你应该知道Unity提供的默认的着色器是基于一个叫<strong>Lambertian reflectance</strong>的光照模型。我们会在这个知识点向你展示如何创建一个自定义的光照模型，并且解释它后面的数学原理和实现方式。下面的两张图分别展示了<strong>标准着色器Standard Shader (右)</strong>和<strong>diffuse Lambert</strong>着色器对同一个几何体进行渲染后，不同的显示效果：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram29.png" /></div><p>基于<strong>Lambertian reflectance</strong>光照模型的着色器是典型的非真实渲染着色器；我们现实生活中没有物体会看起来像那样。然而Lambert 着色器依然能在一些低多边形风格的游戏中经常看到，因为跟一些复杂的几何体比起来，它们的三角面数量对比非常明显。用于计算<strong>Lambertian</strong>反射的光照模型非常高效，这特别适合移动端的游戏。</p><p>Unity其实已经提供了光照函数给我们，好让我们能在着色器中使用。它就是<strong>Lambertian</strong>光照模型。它是光反射模拟的一种更基础更有效率的形式，你能在当今的很多游戏中看到它的存在。 因为它们已经内建在了Unity的表面着色器语言中，所以我从这个开始和基于它开始构建也不失为一个好的选择。你也可以在Unity用户手册中找到一个例子，但我们还是会更深入学习，从而向你解释这些数据是从哪里来的以及为什么它是那样工作的。这些可以为设置光照模型打下一个很好的基础，这些知识将来也能在后面的章节中对我们有帮助。</p><hr /><ul><li><p><strong>始前准备</strong><span id="CCDLM_getting_ready"></span></p><p>让我们从实现下面几个步骤开始：</p><ol><li>创建一个新的着色器并且给它命名好。<li>创建一个新的材质球，命名好，并且把上一步新建的着色器应用于该材质。<li>接下来，创建一个球形对象，并且把它大致放在场景中间的位置。<li>最后，我们创建一个方向光源，让光找到游戏对象上。</ol><p>当你在Unity中设置好这些资源后， 你就会有一个类似于下图的场景：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram30.png" /></div></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="CCDLM_how_to_do_it"></span></p><p><strong>Lambertian</strong>反射可以在着色器中修改下面的代码实现：</p><ol><li>首先在着色器的<strong>属性Properties</strong>块中添加下面的属性：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_MainTex</span><span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span>
</pre></table></code></div></div><li>修改着色器的<strong>#pragma</strong>指示符，从而让着色器使用我们自定义的光照模型，而不是<strong>标准Standard</strong>：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma surface surf SimpleLambert
</span></pre></table></code></div></div><li>使用一个非常简单的<strong>表面函数surface function</strong>，这个函数仅仅通过它的UV数据对纹理进行采样：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span><span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li>添加一个叫做<strong>LightingSimpleLambert()</strong>的函数，这个函数包含了下面实现<strong>Lambertian</strong>反射的代码：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">half4</span> <span class="nf">LightingSimpleLambert</span><span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span><span class="p">,</span><span class="n">half3</span> <span class="n">lightDir</span><span class="p">,</span><span class="n">half</span> <span class="n">atten</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">half</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span><span class="n">lightDir</span><span class="p">);</span>
 <span class="n">half4</span> <span class="n">c</span><span class="p">;</span>
 <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="p">(</span><span class="n">NdotL</span><span class="p">*</span><span class="n">atten</span><span class="p">*</span><span class="m">1</span><span class="p">);</span>
 <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>
 <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ol></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CCDLM_how_it_works"></span></p><p>如我们前面 <a href="#chapter1">第一章</a>，<strong>创建你的第一个着色器</strong> 所看到的那样，<strong>#pragma</strong>指示用于指定我们该用哪个表面函数。选择不同的光照模型都是按照下面同一种方法：<strong>SimpleLambert</strong> 会强制Cg 去寻找一个叫做<strong>LightingSimpleLambert()</strong>函数。注意开始前面的<strong>Lighting</strong>，只是在指示中被省略了。</p><p>这个光照函数接收3个参数：表面输出结构体<strong>surface output</strong>(它包含了物理属性比如<strong>albedo</strong>和<strong>transparency</strong>)，光照照进来的方向<strong>direction</strong>和光的衰减<strong>attenuation</strong>。</p><p>根据<strong>Lambertian</strong> 反射原理, 表面反射光线的数量由表面法线跟入射光线的夹角决定。如果你玩过台球，那么你应该对这个概念比较熟悉；球的方向由球的入射方向跟球桌对应边缘的夹角决定。如果你以90度击球，这个球会垂直返回；如果你以一个非常小的角度击球，球的方向几乎改变很少。<strong>Lambertian</strong>光照模型跟这个很像；如果光以90度的方式照到一个三角面上，所有光线都会被反射回来。入射的角度越小，返回来的光线也会越少。下面的图片解释了这个概念：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram31.png" /></div><p>把这个简单的概念转换成数学概念。在向量代数中，两个单位向量的夹角可以通过<strong>点积dot product</strong>计算 。当点积的值为零，两个向量垂直，也就是说它们之间的夹角是90度。当点积为1(或或者-1)时，那么这连个向量相互平行。在Cg语言中的函数<strong>dot()</strong>，以极其高效的方式实现了点积。</p><p>下图展示了一束阳光照射到了一个复杂的表面。<strong>L</strong> 指光的方向(就是着色器中的<strong>lightDir</strong>)，<strong>N</strong>是表面的法线。光线以相同的角度反射，反射角跟入射角相同：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram32.png" /></div><p><strong>Lambertian</strong>反射简单的使用 <strong>NdotL</strong>点积作为光强度的相乘的系数：</p><p><strong><em>I</em></strong> = <strong><em>N</em></strong> <strong>*</strong> <strong><em>L</em></strong></p><p>当<strong>N</strong> 跟 <strong>L</strong> 平行的时候，光线会反射回来，从这个角度看这个几何图形会非常的亮。<strong>_LightColor0</strong>这个变量包含了对光进行计算后的到的颜色。</p><p><strong>注意</strong></p><p>Unity5之前的引擎，光强(<strong>intensity of the lights</strong>)是不一样的。如果你使用的是基于<strong>Lambertian</strong>反射模型的旧的漫反射着色器，你会发现<strong>NdotL</strong>乘了两个参数：是<strong>(NdotL * atten * 2)</strong>而不是<strong>(NdotL * atten)</strong>。如果你从Unity4中导入的自定义的着色器，需要你手动纠正这点。而Unity自带的一些老的着色器在设计的时候已经考虑到这点了，帮你纠正了。</p><p>当点积是负数的时候，这个光是来自三角面的背面。 这对不透明的几何体没有问题，因为摄像机只会渲染朝前面向摄像机的三角面，否则就会被剔除，不去渲染。</p><p>这个基本的<strong>Lambert</strong>光照模型很适合用于构建自己的着色器原型，因为它已经有了着色器中光照模型的核心功能。</p><p>Unity已经为我们创建<strong>Lambert</strong>光照模型提供了原型。在你的Unity安装目录下的<strong>Editor/Data/CGIncludes</strong>文件夹内照到<strong>UnityCG.cginc</strong>文件，会发现其实已经有<strong>Lamber</strong>和<strong>BlinnPhong</strong>光照模型了。当你使用<strong>#pragma surface surf Lambert</strong>指示编译着色器时，等于是告诉着色器请使用Unity提供的<strong>UnityCG.cginc</strong>文件中的<strong>Lambert</strong>光照模型，这样我们就不用重复造轮子。我们会在这章的稍后部分探索<strong>BlinnPhong</strong>光照模型。</p></ul><hr /><p><span id="CATS"></span></p><h2 id="创建一个toon风格的着色器">创建一个Toon风格的着色器</h2><p><strong>Toon着色器(toon shading)</strong>是游戏中最常使用的效果之一，也被称作(AKA)<strong>cel shading</strong>(cel是celluloid的缩写[中文也叫 赛璐珞])。它是一种非真实渲染技术，可以让3D模型呈现一种平面效果。许多游戏中用这种着色器把3D的物体渲染成一种手绘物体的效果。下图中你能看到这两者的区别，右边的是标准着色器，左边的是Toon着色器：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram33.png" /></div><p>如果只使用<strong>表面函数(surface functions)</strong>虽然也能获得这样的效果，但是花费性能和时间的代价太大了。表面函数仅仅对材质的属性起作用，而对材质的具体光照环境无能为力。因为toon着色器需要改变光的反射方式，所以我们接下来要创建我们自己的光照模型。</p><hr /><ul><li><p><strong>始前准备</strong><span id="CATS_getting_ready"></span></p><p>开始学习这个知识点之前，我们先创建一个着色器和对应的材质球，而且需要导入一个特殊的纹理，步骤如下：</p><ol><li><p>创建一个新的着色器；在这例子中，我们会用上一个知识点的着色器进行扩展</p><li><p>为着色器创建一个新的材质，并且把它应用到3D模型中。 拥有曲面的模型对于toon着色器来说最好。</p><li><p>这个知识点需要一张额外的纹理，叫做<strong>ramp</strong>贴图[如果要全译，我把它叫梯度贴图]。有一点很重要，在导入的时候把<strong>Wrap Mode</strong>改为<strong>Clamp</strong>，如果你想让颜色的边缘变得灵敏，就把<strong>Filter Mode</strong>设置为<strong>Point</strong> ：</p></ol><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram34.png" /></div><hr /><li><p><strong>操作步骤</strong><span id="CATS_how_to_do_it"></span></p><p>通过下面的步骤我们可以获得toon风格的特殊审美呈现：</p><ol><li>添加一个新的叫<strong>_RampTex</strong>纹理属性：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">_RampTex</span> <span class="p">(</span><span class="s">"Ramp"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
</pre></table></code></div></div><li>同时在<strong>CGPROGRAM</strong>块中添加对应的变量：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sampler2D</span> <span class="n">_RampTex</span><span class="p">;</span>
</pre></table></code></div></div><li>修改<strong>#pragma</strong>指示 ，从而让着色器使用一个叫<strong>LightingToon()</strong>的函数：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma surface surf Toon
</span></pre></table></code></div></div><li>使用下面这个光照模型：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">LightingToon</span><span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span> <span class="p">,</span><span class="n">fixed3</span> <span class="n">lightDir</span><span class="p">,</span><span class="k">fixed</span> <span class="n">atten</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">half</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span><span class="n">lightDir</span><span class="p">);</span>
 <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_RampTex</span><span class="p">,</span><span class="nf">fixed2</span><span class="p">(</span><span class="n">NdotL</span><span class="p">,</span><span class="m">0.5</span><span class="p">));</span>
 <span class="n">fixed4</span> <span class="n">c</span><span class="p">;</span>
 <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">*</span><span class="n">NdotL</span><span class="p">*</span><span class="n">atten</span><span class="p">;</span>
 <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>
 <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ol></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CATS_how_it_works"></span></p><p>toon风格着色器的主要特征是它的光的渲染方式；表面并非均匀的着色。为了能达这种效果，我们需要一张<strong>ramp</strong>贴图。他的作用是对<strong>Lambertian</strong>的光线强度<strong>NdotL</strong>重新映射，然后把值赋值给另一个值。我们使用一张<strong>ramp</strong>贴图而不是一个梯度值，是为了强制光线按照步骤渲染。下图展示了<strong>ramp</strong>贴图是如何纠正光的强度的：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram35.png" /></div><hr /><li><p><strong>相关补充</strong><span id="CATS_there_is_more"></span></p><p>我们有很多不同方式来获得toon着色器效果。 我们可以使用不同的<strong>ramp</strong>贴图来让我们的模型看起来更有吸引力，这就需要你们自己去试试了，然后找到一张你认为最好的。</p><p>还有另一种可选方法对纹理进行梯度采样，就是通过对光强度<strong>NdotL</strong>进行截断取值，这样就只能在0到1的范围内给它赋值特定的值：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">LightingToon</span><span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span> <span class="p">,</span><span class="n">fixed3</span> <span class="n">lightDir</span><span class="p">,</span><span class="k">fixed</span> <span class="n">atten</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">half</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span><span class="n">lightDir</span><span class="p">);</span>
    <span class="n">half</span> <span class="n">cel</span> <span class="p">=</span> <span class="nf">floor</span><span class="p">(</span><span class="n">NdotL</span> <span class="p">*</span> <span class="n">_CelShadingLevels</span><span class="p">)/(</span><span class="n">_CelShadingLevels</span> <span class="p">-</span> <span class="m">0.5</span><span class="p">);</span>
    <span class="n">half4</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">*</span><span class="n">cel</span><span class="p">*</span><span class="n">atten</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>截断取值部分的代码中，<strong>NdotL</strong>乘以了倍数<strong>_CelShadingLevels</strong>并且把它进行了取整，而得到了一个整数，接着又把结果除了回去。通过上面的这些步骤后， 变量<strong>cel</strong>被赋值，这个值的范围是0到1之间的值，而且这个值跟<strong>_CelShadingLevels</strong>相等。有了这个，我们就不再需要<strong>ramp</strong>纹理了而且所有的颜色梯度也在这个范围。如果你正在你的着色中实现这个功能，不要忘记在你的着色器中添加<strong>_CelShadingLevels</strong>属性。</p></ul><hr /><p><span id="CPST"></span></p><h2 id="创建一个phong类型类型的高光反射着色器">创建一个Phong类型类型的高光反射着色器</h2><p>一个物体表面的高光，可以简单的理解为它表面的亮度。这种类型的着色器常用于视野特效(view-dependent effects)。这是因为 为了在着色器中获得贴近现实的高光效果，你需要考虑到摄像机和人的朝向因素。而<strong>Phong</strong>高光效果是最基础和性能较好的一种着色器效果。它根据人的朝向和光的反射方向，通过计算获得一个有方向的反射。 在应用程序中，这种高光模型非常常见，涵盖游戏行业到电影等产业。虽然它在高光反射模型的精确度上不是最接近现实的，但是在大多数情况下，它大致都能满足而且性能不赖。此外，如果你的游戏对象离摄像机很远，就没有必要在提供准确的高光，这对你的高光效果着色器来说是好事。</p><p>在这个知识点中，我们会涉及到如何使用表面着色器的<strong>输入(Input)</strong>结构体中的一些新参数进行逐顶点和逐像素的操作。我们会了解它们之间的区别，而且还会讨论什么时候以及为什么要用这两种不同的实现方式，来应对不同的情况。</p><hr /><ul><li><p><strong>始前准备</strong><span id="CPST_getting_ready"></span></p><p>我们按照下面的步骤来学习这次的知识点：</p><ol><li>分别创建一个新的着色器，材质和游戏对象，为了在后面你容易照到它们，请给它们恰当命名。<li>创建一个新场景，在创建一个新的游戏对象，把着色器应用到材质，然后再把材质应用到游戏对象上。 再添加一个平行光源，这是为了让我们方便看我们着色器代码的高光效果。</ol></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="CPST_how_to_do_it"></span></p><p>请按照下面的步骤创建一个<strong>Phong</strong>类型的光照模型：</p><ol><li>此时你可能发现了一个模式，在我们开始写着色器的时候都有的步骤：着色器属性的创建。所以，让我们先在着色器中添加下面的一些属性：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">Properties</span>
<span class="p">{</span>
<span class="nf">_MainTint</span> <span class="p">(</span><span class="s">"Diffuse Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
<span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Base (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="nf">_SpecularColor</span> <span class="p">(</span><span class="s">"Specular Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
<span class="nf">_SpecPower</span> <span class="p">(</span><span class="s">"Specular Power"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">30</span><span class="p">))</span> <span class="p">=</span> <span class="m">1</span>
<span class="p">}</span>
</pre></table></code></div></div><li>接下来在<strong>CGPROGRAM</strong>块中的<strong>SubShader{}</strong>块中，添加与之对应的一些变量：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">float4</span> <span class="n">_SpecularColor</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_MainTint</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_SpecPower</span><span class="p">;</span>
</pre></table></code></div></div><li>现在我们要添加我们自定义的光照模型，因为我们要计算自己的<strong>Phong</strong>高光。如果你现在还不能理解下面的代码也不用担心；在<strong>原理介绍</strong>的部分我们会解释每一行代码的作用。在着色器的<strong>SubShader{}</strong>中添加下述代码：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">LightingPhong</span> <span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span><span class="p">,</span> <span class="n">fixed3</span> <span class="n">lightDir</span><span class="p">,</span> <span class="n">half3</span> <span class="n">viewDir</span><span class="p">,</span><span class="k">fixed</span> <span class="n">atten</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Reflection</span>
  <span class="kt">float</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">);</span>
  <span class="n">float3</span> <span class="n">reflectionVector</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="m">2.0</span> <span class="p">*</span> <span class="n">s</span><span class="p">.</span><span class="n">Normal</span> <span class="p">*</span> <span class="n">NdotL</span> <span class="p">-</span> <span class="n">lightDir</span><span class="p">);</span>
  <span class="c1">// Specular</span>
  <span class="kt">float</span> <span class="n">spec</span> <span class="p">=</span> <span class="nf">pow</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="nf">dot</span><span class="p">(</span><span class="n">reflectionVector</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">)),</span> <span class="n">_SpecPower</span><span class="p">);</span>
  <span class="n">float3</span> <span class="n">finalSpec</span> <span class="p">=</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">spec</span><span class="p">;</span>
  <span class="c1">// Final effect</span>
  <span class="n">fixed4</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="nf">max</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="n">NdotL</span><span class="p">)</span> <span class="p">*</span> <span class="n">atten</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">finalSpec</span><span class="p">);</span>
  <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li>最后，我们还要告诉<strong>CGPROGRAM</strong>块，需要用我们自定义的光照模型而不是Unity内建的光照模型。 按照下面的步骤修改<strong>#pragma</strong>指示：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">CPROGRAM</span>
<span class="cp">#pragma surface surf Phong
</span></pre></table></code></div></div><p>下图演示了我们自定义的<strong>Phong</strong>光照模型的效果，里面的反射算法也是我们自己的：</p></ol><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram36.png" /></div></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CPST_how_it_works"></span></p><p>我们现在先把光照函数放一放，因为着色器剩下的部分你应该感到很熟悉了。</p><p>在上一个知识点中，我们使用的光照函数只提供了光的方向，<strong>lightDir</strong>。Unity本身有一些现成的光照函数配置可以使用，其中一个就是视角方向，<strong>viewDir</strong>。可以根据下表或者下面的这个链接<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaderLighting.html">https://docs.unity3d.com/Manual/SL-SurfaceShaderLighting.html</a>详细了解：</p><div class="table-wrapper"><table><tr><td>Not view dependent<td>half4 Lighting Name You choose (SurfaceOutput s, half3 lightDir, half atten);<tr><td>View-dependent<td>half4 Lighting Name You choose (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);</table></div><p>在我们的这个例子中，我们处理的是一个高光着色器，所以我们需要基于视角的光线函数结构。所以我们需要编写下面的着色器代码：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">CPROGRAM</span>
<span class="cp">#pragma surface surf Pong
</span><span class="n">fixed4</span> <span class="nf">LightingPhong</span> <span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span><span class="p">,</span> <span class="n">fixed3</span> <span class="n">lightDir</span><span class="p">,</span> <span class="n">half3</span> <span class="n">viewDir</span><span class="p">,</span><span class="k">fixed</span> <span class="n">atten</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>  
</pre></table></code></div></div><p>这样写会告诉着色器我们要创建我们自己的基于视角的着色器。请注意，你声明的的光线函数的名字要跟<strong>#pragma</strong>指示那里保持一致[<strong>#pragma</strong>指示那里省略了前缀<strong>“Lighting”</strong>]，否则Unity没有办法定位到你的光照模型。</p><p>在<strong>Phong</strong>类型光照模型中的这部分内容，我们用下面的图来描述。<strong>L</strong>是光的方向(<strong>R</strong>是跟它成对出现的反射光线方向)，<strong>N</strong>是物体表面的法线方向。我们在前面讲解<strong>Lambertian</strong>光照模型的时候讲到过，<strong>V</strong>是我们没有讲到的，就是这里的视角方向：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram37.png" /></div><p><strong>Phong</strong>光照模型给我们呈现了反射表面的最终光强，它由两部分得出：他的的漫反射颜色(<strong>diffuse color</strong>)和高光值(<strong>Specular value</strong>)，如下所示：</p>\[I = D + S\]<p>漫反射部分<strong>D</strong>是来自<strong>Lambertian</strong>光照模型，这部分没有改变过：</p>\[D = N \cdot L\]<p>高光部分<strong>S</strong>的定义如下：</p>\[S = (R \cdot V)^{p}\]<p>这里,，<strong><em>p</em></strong> 是高光的力度，就是在着色器中的<strong>_SpecPower</strong>。唯一不知道参数就是<strong><em>R</em></strong>，这是光线<strong><em>L</em></strong>根据法线方向<strong><em>N</em></strong>计算出来的反射光。在向量的代数运算中，它可以通过下面的表达式计算出来：</p>\[R = 2N \cdot (N \cdot L) - L\]<p>这个公式就是着色器中下面的这行代码的具体含义：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">float3</span> <span class="n">reflectionVector</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="m">2.0</span> <span class="p">*</span> <span class="n">s</span><span class="p">.</span><span class="n">Normal</span> <span class="p">*</span> <span class="n">NdotL</span> <span class="p">-</span> <span class="n">lightDir</span><span class="p">);</span>  
</pre></table></code></div></div><p>这能让法线有偏向光的效果；当法向量朝向远离光的方向时，反射光线的方向就会越接近入射光线的方向。 下面的图片能给帮助你更好的理解。而产生图中那样的调试效果的脚本，你可以从本书的支持网页中下载，链接：<a href="https://www.packtpub.com/support/code-downloads">https://www.packtpub.com/support/code-downloads</a>[记得在下面第二张图中的位置输入书名]:</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram38.png" /></div><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram39.png" /></div><p>下图展示了我们的<strong>Phong</strong>高光着色器最终的计算结果：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram40.png" /></div></ul><hr /><p><span id="CBST"></span></p><h2 id="创建-blinnphong-类型的高光反射着色器">创建 BlinnPhong 类型的高光反射着色器</h2><p><strong>Blinn</strong>是另一种计算和模拟高光的更有效的方法。它只要视角方向和光线方向向量的中间向量就可以计算出来。这个高光是<strong>Jim Blinn</strong>带入到Cg世界中的。 他发现比起计算反射向量来，只要中间向量的效率更好。它减少了代码量和处理时间。 如果你在<strong>UnityCG.cginc</strong>文件中查看了Unity内建的<strong>BlinnPhong</strong>光照模型的话，它也是用了中间向量，因此它被命名为<strong>BlinnPhong</strong> 。它只是完整<strong>Phong</strong>光照计算中的一种简单的版本。</p><hr /><ul><li><p><strong>始前准备</strong><span id="CBST_getting_ready"></span></p><p>让我们按照下面的步骤开始学习这个知识点：</p><ol><li>这次我们不创建新的场景，就用原来场景和场景内的对象就好，然后我们需要创建一个新的着色器和材质，并且把名字都叫<strong>BlinnPhong</strong>。<li>当我们创建好着色器后，双击它，开始编辑。</ol></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="CBST_how_to_do_it"></span></p><p>按照下面的步骤走，我们来创建<strong>BlinnPhong</strong>光照模型：</p><ol><li>首先，我们需要在着色器的<strong>属性(Properties)</strong>块中添加我们需要用到的属性，这样好让我们控制高光效果：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">Properties</span>
<span class="p">{</span>
  <span class="nf">_MainTint</span> <span class="p">(</span><span class="s">"Diffuse Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
  <span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Base (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
  <span class="nf">_SpecularColor</span> <span class="p">(</span><span class="s">"Specular Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
  <span class="nf">_SpecPower</span> <span class="p">(</span><span class="s">"Specular Power"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0.1</span><span class="p">,</span><span class="m">60</span><span class="p">))</span> <span class="p">=</span> <span class="m">3</span>
<span class="p">}</span>
</pre></table></code></div></div><li>接下来在<strong>CGPROGRAM</strong>块中添加与属性对应的变量，这样我们就可以获得来自<strong>属性(Properties)</strong>中的数据：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_MainTint</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_SpecularColor</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_SpecPower</span><span class="p">;</span>
</pre></table></code></div></div><li>接下来就是要创建我们自定义的光照模型了，用来处理漫反射和高光的计算，代码如下所示:<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">LightingCustomBlinnPhong</span> <span class="p">(</span><span class="n">SurfaceOutput</span> <span class="n">s</span><span class="p">,</span> <span class="n">fixed3</span> <span class="n">lightDir</span><span class="p">,</span><span class="n">half3</span> <span class="n">viewDir</span><span class="p">,</span> <span class="k">fixed</span> <span class="n">atten</span><span class="p">)</span>
<span class="p">{</span>
 <span class="kt">float</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">));</span>
 <span class="n">float3</span> <span class="n">halfVector</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="p">+</span> <span class="n">viewDir</span><span class="p">);</span>
 <span class="kt">float</span> <span class="n">NdotH</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span> <span class="n">halfVector</span><span class="p">));</span>
 <span class="kt">float</span> <span class="n">spec</span> <span class="p">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">NdotH</span><span class="p">,</span> <span class="n">_SpecPower</span><span class="p">)</span> <span class="p">*</span> <span class="n">_SpecularColor</span><span class="p">;</span>
 <span class="n">float4</span> <span class="n">c</span><span class="p">;</span>
 <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">NdotL</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">spec</span><span class="p">)</span> <span class="p">*</span> <span class="n">atten</span><span class="p">;</span>
 <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>
 <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li>为了完成我们的着色器，我们还需要告知着色器的<strong>CGPROGRAM</strong>块使用我们自定义的光照模型而不是Unity内建的，修改<strong>#pragma</strong>指示，改成如下代码所示：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">CPROGRAM</span>
<span class="cp">#pragma surface surf CustomBlinnPhong
</span></pre></table></code></div></div><p>下图演示了我们自己的<strong>BlinnPhong</strong>光照模型的效果：</p></ol><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram41.png" /></div></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CBST_how_it_works"></span></p><p><strong>BlinnPhong</strong>高光跟<strong>Phong</strong>高光很像，但是前者的效率比后者要高，因为后者用更优化的代码实现了几乎一样的效果。在介绍基于物理原理的渲染之前，这种方法是Unity4中高光反射的默认选择。 计算反射向量<strong>R</strong>的代价通常很高。<strong>BlinnPhong</strong>高光并没有计算它，而是用介于视角<strong>V</strong>和光线<strong>L</strong>之间的中间向量<strong>H</strong>：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram42.png" /></div><p>跟完整的计算出我们的反射向量不同，我们转而去获得介于视角方向和光线方向之间的中间向量，基本模拟了反射向量。跟<strong>Phong</strong>高光比起来，这种方法更加贴近真实的物理现象，但是我们依然认为，向你介绍所有的这些方法依然是很有必要的：</p>\[S_{Phong} = (R \cdot V)^p, S_{BlinnPhong} = (N \cdot H)^p\]<p>根据向量的代数计算，中间向量可以用下面的方法算出：</p>\[H\frac{V+L}{|V+L|}\]<p>这里 的$|V+L|$表示向量$V+L$的长度。在Cg中，我们简单的将视角方向和光线方向相加并且对结果进行标准化成一个单位向量：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">float3</span> <span class="n">halfVector</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="p">+</span> <span class="n">viewDir</span><span class="p">);</span>  
</pre></table></code></div></div><p>然后，我们简单的对顶点的法线和我们的中间向量求点积，从而获得我们主要的高光值。在这之后，我们把它用指数<strong>_SpecPower</strong>进行指数运算并且乘以高光颜色变量<strong>_SpecularColor</strong>。跟<strong>Phong</strong>高光比起来，整个算法在代码量和运算量上都要少很多，但在很多实时渲染情况中，它依然能给我们带来很好的高光效果。</p><hr /><li><p><strong>额外内容</strong><span id="CBST_there_is_more"></span></p><p>在这一章介绍的光照模型都非常的简单；现实中我们是找不出完全粗糙或完全光滑的材料的。要知道，生活中复杂的材料是很常见的，比如衣服，木材和皮肤等等，这些材质涉及到物体表面下层的光如何散射的知识。</p><p>我们用下面的表格来回顾我们之前学些过的不同光照模型知识：</p><div class="table-wrapper"><table><thead><tr><th>Technique<th>Type<th>Unity 5 shader<th>Light Intensity (I)<tbody><tr><td>Lambertian<td>Diffuse<td>Legacy Shaders | Diffuse<td>$I = N \cdot L$<tr><td>Phong<td>Specular<td> <td>$I = N \cdot L + (R \cdot V)^p$         $R = 2N\cdot(N \cdot L) - L$<tr><td>BlinnPhong<td>Specular<td>Legacy Shaders | Specular<td>$I = N \cdot L +(N \cdot H)^p $      $H = \frac{V+L}{|V+L|}$</table></div><p>下面的链接有一些关于粗糙表面的更有趣的光照模型，比如<strong>Oren-Nayar</strong>：</p><p><a href="https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model">https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model</a></p></ul><hr /><p><span id="CAAST"></span></p><h2 id="创建各向异性类型的高光反射着色器">创建各向异性类型的高光反射着色器</h2><p><strong>各向异性(Anisotropic)</strong>类型可以用来模拟高光或者反射，常用于表面凹槽的方向和高光在垂直方向上的扭曲形变。当你想模拟金属抛光表面的时候这种类型的着色器就会非常有用，因为这种表面并不干净，光滑和明亮。 你可以想象当你看CD或者VCD光盘的数据那面时的高光或者底面被打磨过的金属盘子和盆子。 当你仔细检查这些表面的时候你会发现，表面的这些沟纹是有方向的，通常就是被抛光的方向。当你对这样的表面应用高光时，在垂直方向上会被扭曲。</p><p>这个知识点中我们会向你介绍不同的抛光表面高光概念。在将来的一些知识点中，我们会探索如何使用这个知识点介绍的一些概念来获得一些类似于头发的扭曲反射效果，但是在这里我们还是要先学习这个技术的一些原理知识。我们自定义的各向异性着色器将使用下面这个着色器作为参考：</p><p><a href="http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader">http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader</a></p><p>下图展示了使用<strong>各向异性(Anisotropic)</strong>着色器能获得的不同类型高光效果：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram43.png" /></div><hr /><ul><li><p><strong>始前准备</strong><span id="CAAST_getting_ready"></span></p><p>让我们开始学习新的知识点吧，先按照下面的步骤在场景中创建一个着色器，材质和一些光源：</p><ol><li>创建一个新的场景，在场景中添加一些游戏对象，添加一个平行光源，这样我们好可视化的调试我们的着色器。<li>创建一个新的着色器和材质，它们都应用到刚刚创建的游戏对象上去。<li>最后，我们需要某种法线贴图，它能指出我们各向异性类型高光的方向。</ol><p>下图展示的就是这个知识点要用的各向异性类型的法线贴图。在本书的支持网页中可以获得[就在本书附带的工程代码中，获取方法前面有介绍]:</p><p><a href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a></p></ul><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram44.png" /></div><hr /><ul><li><p><strong>操作步骤</strong><span id="CAAST_how_to_do_it"></span></p><p>为了获得各向异性效果，我们需要对我们前面创建的着色器进行如下的修改：</p><ol><li>首先得再着色器中添加我们需要用到的一些属性。这些属性允许我们控制很多中艺术效果从而最终决定表面的效果呈现：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="p">{</span>
<span class="nf">_MainTint</span> <span class="p">(</span><span class="s">"Diffuse Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
<span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Base (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="nf">_SpecularColor</span> <span class="p">(</span><span class="s">"specular Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
<span class="nf">_Specular</span> <span class="p">(</span><span class="s">"Specular Amount"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
<span class="nf">_SpecPower</span> <span class="p">(</span><span class="s">"Specular Power"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
<span class="nf">_AnisoDir</span> <span class="p">(</span><span class="s">"Anisotropic Direction"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">""</span> <span class="p">{}</span>
<span class="nf">_AnisoOffset</span> <span class="p">(</span><span class="s">"Anisotropic Offset"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="p">-</span><span class="m">0.2</span>
<span class="p">}</span>
</pre></table></code></div></div><li>接着我们要让我们的<strong>SubShader{}</strong>代码块跟我们的<strong>属性(Properties)</strong>块关联起来，这样才能让我们使用<strong>属性(Properties)</strong>中的数据：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_AnisoDir</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_MainTint</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_SpecularColor</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_AnisoOffset</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_Specular</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_SpecPower</span><span class="p">;</span>
</pre></table></code></div></div><li>接下来我们要创建我们自己的光照函数，用来处理物体表面的各向异性效果。我们的代码如下：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">LightingAnisotropic</span><span class="p">(</span><span class="n">SurfaceAnisoOutput</span> <span class="n">s</span><span class="p">,</span> <span class="n">fixed3</span> <span class="n">lightDir</span><span class="p">,</span> <span class="n">half3</span> <span class="n">viewDir</span><span class="p">,</span> <span class="k">fixed</span> <span class="n">atten</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">fixed3</span> <span class="n">halfVector</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">normalize</span><span class="p">(</span><span class="n">lightDir</span><span class="p">)</span> <span class="p">+</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">viewDir</span><span class="p">));</span>
  <span class="kt">float</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">));</span>
  <span class="k">fixed</span> <span class="n">HdotA</span> <span class="p">=</span> <span class="nf">dot</span><span class="p">(</span><span class="nf">normalize</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span> <span class="p">+</span> <span class="n">s</span><span class="p">.</span><span class="n">AnisoDirection</span><span class="p">),</span><span class="n">halfVector</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">aniso</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="nf">sin</span><span class="p">(</span><span class="nf">radians</span><span class="p">((</span><span class="n">HdotA</span> <span class="p">+</span> <span class="n">_AnisoOffset</span><span class="p">)</span> <span class="p">*</span> <span class="m">180</span><span class="p">)));</span>
  <span class="kt">float</span> <span class="n">spec</span> <span class="p">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="nf">pow</span><span class="p">(</span><span class="n">aniso</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">Gloss</span> <span class="p">*</span> <span class="m">128</span><span class="p">)</span> <span class="p">*</span> <span class="n">s</span><span class="p">.</span><span class="n">Specular</span><span class="p">);</span>
  <span class="n">fixed4</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="p">=</span> <span class="p">((</span><span class="n">s</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">NdotL</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span>
  <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">rgb</span> <span class="p">*</span> <span class="n">spec</span><span class="p">))</span> <span class="p">*</span> <span class="n">atten</span><span class="p">;</span>
  <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Alpha</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li>为了使用我们新的光照函数，我们需要修改<strong>#pragma</strong>指示，让Unity去使用我们的光照函数，而不是Unity内建的光照函数。我们同时还要告诉着色器目标着色器模式是3.0，这样我们可以让我们的程序拥有更多的空间用来存放纹理：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">CGPROGRAM</span>
<span class="cp">#pragma surface surf Anisotropic
#pragma target 3.0
</span></pre></table></code></div></div><li>为了让各向异性法线贴图能使用它自己的UV数据，我们需要再<strong>输入(Input)</strong>结构中添加如下定义代码。 我们其实并不是说完全需要这样做，因为我们也可以使用主帖图上的UV数据，但是如果有它自己单独UV数据的话我们就能单独控制金属抛光效果的截取，这样我们就可以把它进行缩放任何我们想要的大小：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">{</span>
  <span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
  <span class="n">float2</span> <span class="n">uv_AnisoDir</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><li>我们还需要定义<strong>SurfaceAnisoOutput</strong>这个输出结构体：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">SurfaceAnisoOutput</span>
<span class="p">{</span>
  <span class="n">fixed3</span> <span class="n">Albedo</span><span class="p">;</span>
  <span class="n">fixed3</span> <span class="n">Normal</span><span class="p">;</span>
  <span class="n">fixed3</span> <span class="n">Emission</span><span class="p">;</span>
  <span class="n">fixed3</span> <span class="n">AnisoDirection</span><span class="p">;</span>
  <span class="n">half</span> <span class="n">Specular</span><span class="p">;</span>
  <span class="k">fixed</span> <span class="n">Gloss</span><span class="p">;</span>
  <span class="k">fixed</span> <span class="n">Alpha</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><li>最后，我们需要通过表面函数<strong>surf()</strong>给我们的光照函数传递正确的数据。这样，我们将会获得我们各向异性法线贴图的每个像素信息，然后像下面的代码一样设置我们的高光参数：<div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">surf</span><span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceAnisoOutput</span> <span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">half4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="p">*</span> <span class="n">_MainTint</span><span class="p">;</span>
  <span class="n">float3</span> <span class="n">anisoTex</span> <span class="p">=</span> <span class="nf">UnpackNormal</span><span class="p">(</span><span class="nf">tex2D</span><span class="p">(</span><span class="n">_AnisoDir</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_AnisoDir</span><span class="p">));</span>
  <span class="n">o</span><span class="p">.</span><span class="n">AnisoDirection</span> <span class="p">=</span> <span class="n">anisoTex</span><span class="p">;</span>
  <span class="n">o</span><span class="p">.</span><span class="n">Specular</span> <span class="p">=</span> <span class="n">_Specular</span><span class="p">;</span>
  <span class="n">o</span><span class="p">.</span><span class="n">Gloss</span> <span class="p">=</span> <span class="n">_SpecPower</span><span class="p">;</span>
  <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
  <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>各向异性法线贴图允许我们给出表面的方向并且能帮助我们分散物体表面周围的高光效果。下图就是我们的各向异性着色器的效果：</p></ol><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram45.png" /></div></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CAAST_how_it_works"></span></p><p>我们按部分来看看这个着色器的核心内容并且解释为什么我们能获得这样的效果。这里我们大部分都讲光照函数部分，因为除此之外的内容对于当前的你来说都能自己理解。</p><p>首先我们定了我们自己的结构体<strong>SurfaceAnisoOutput</strong>。我们之所以这样么做是因为我们需要获得各向异性法线贴图的每个像素信息，而再表面着色器中获得这个的唯一方法就是在<strong>surf()</strong>函数中使用<strong>tex2D()</strong>函数获取。 下面的代码就是我们在着色器中自定义的输出结构体：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">SurfaceAnisoOutput</span>
<span class="p">{</span>
    <span class="n">fixed3</span> <span class="n">Albedo</span><span class="p">;</span>
    <span class="n">fixed3</span> <span class="n">Normal</span><span class="p">;</span>
    <span class="n">fixed3</span> <span class="n">Emission</span><span class="p">;</span>
    <span class="n">fixed3</span> <span class="n">AnisoDirection</span><span class="p">;</span>
    <span class="n">half</span> <span class="n">Specular</span><span class="p">;</span>
    <span class="k">fixed</span> <span class="n">Gloss</span><span class="p">;</span>
    <span class="k">fixed</span> <span class="n">Alpha</span><span class="p">;</span>
<span class="p">};</span>  
</pre></table></code></div></div><p><strong>SurfaceAnisoOutput</strong>输出结构体是光线函数和表面函数进行交互的中间数据。在我们这个例子中，<strong>surf()</strong>中我们把每个像素的纹理信息都保存在了<strong>anisoTex</strong>中，接着把<strong>anisoTex</strong>保存在了<strong>AnisoDirection</strong>变量中，再然后<strong>AnisoDirection</strong>被传递到了表面结构体<strong>SurfaceAnisoOutput</strong>中。一旦我们拥有了这个表面结构体，我们就能在我们的光照函数中使用这每个像素的纹理信息了。</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">s</span><span class="p">.</span><span class="n">AnisoDirection</span><span class="p">.</span>  
</pre></table></code></div></div><p>当我们设置好这部分数据关联后，我们就可以着手我们具体的光照计算了。跟往常不一样，这里我们使用了中间向量，这样我们就不用去进行完整的反射计算和漫反射计算，因为这些计算都需要让顶点的法向量跟光线或光的方向进行点积的运算。我们的Cg代码如下所示:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">fixed3</span> <span class="n">halfVector</span> <span class="p">=</span> <span class="nf">normalize</span><span class="p">(</span><span class="nf">normalize</span><span class="p">(</span><span class="n">lightDir</span><span class="p">)</span> <span class="p">+</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">viewDir</span><span class="p">));</span>
<span class="kt">float</span> <span class="n">NdotL</span> <span class="p">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="nf">dot</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">));</span>
</pre></table></code></div></div><p>之后，我们开始对高光进行具体的修改，以便获得我们想要的视觉效果。我们首先把顶点法线跟我们各向异性法线贴图的顶点相加得到和，再对和进行标准化，然后把标准化后的向量跟前面步骤获得的<strong>中间向量(halfVector)</strong>进行点积操作。参考它跟各向异性法线贴图的点积，当值等于1时，说明表面法线跟<strong>中间向量(halfVector)</strong>平行，当值等于0时，它们相互垂直。最后我们还要用<strong>sin()</strong>函数来修改这个值，这样根据<strong>中间向量(halfVector)</strong>我们基本能获得一个更暗一些的中间亮度，并且最终获得一个环状的效果。所有上面提及的操作都包含在了下面两行Cg代码中：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">fixed</span> <span class="n">HdotA</span> <span class="p">=</span> <span class="nf">dot</span><span class="p">(</span><span class="nf">normalize</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Normal</span> <span class="p">+</span> <span class="n">s</span><span class="p">.</span><span class="n">AnisoDirection</span><span class="p">),</span> <span class="n">halfVector</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">aniso</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="nf">sin</span><span class="p">(</span><span class="nf">radians</span><span class="p">((</span><span class="n">HdotA</span> <span class="p">+</span> <span class="n">_AnisoOffset</span><span class="p">)</span> <span class="p">*</span> <span class="m">180</span><span class="p">)));</span>  
</pre></table></code></div></div><p>最后，我们通过<strong>s.Gloss</strong>对<strong>aniso</strong>进行指数放大，从而放大效果， 然后再通过乘以<strong>s.Specular</strong>来全局减少它的强度：</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">spec</span> <span class="p">=</span> <span class="nf">saturate</span><span class="p">(</span><span class="nf">pow</span><span class="p">(</span><span class="n">aniso</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">Gloss</span> <span class="p">*</span> <span class="m">128</span><span class="p">)</span> <span class="p">*</span> <span class="n">s</span><span class="p">.</span><span class="n">Specular</span><span class="p">);</span>  
</pre></table></code></div></div><p>这个效果非常适合创建一些更加高级的金属类型的表面，尤其时那些表面被有向抛过光的。当然它也非常适合头发反光或者任何表面有方向性的软表面。下图展示了各向异性光照计算的最终显示效果：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram46.png" /></div></ul><hr /><p><span id="PBRIU5"></span></p><h2 id="unity-5中基于物理原理的渲染">Unity 5中基于物理原理的渲染</h2><p><strong>基于物理原理的渲染physically-based rendering</strong>是Unity5中加入的最大的变化之一，也就是我们常说的<strong>PBR</strong>。前面的一些章节重复提到过它但是没有却没向大家过多的展现。如果你不仅想知道PBR的工作原理，还想搞明白如何构建它们，那么这一张正是你需要阅读的。</p><p>在这一章，你将会学习下面的几个知识点：</p><ul><li>理解金属质感的设置<li>向PBR中添加透明度<li>创建镜子和反射面<li>烘培场景中的光</ul><hr /><ul><li><p><strong>介绍</strong><span id="PBRIU5_introduction"></span></p><p>我们在<strong><a href="https://linkliu.github.io/game-tech-post/posts/%E7%90%86%E8%A7%A3%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/">第三章</a></strong>，<strong>理解光照模型</strong> 中介绍了所有的光照模型，简单的讨论了一下光是如何表现的。在编写它们的时候<strong>效率efficiency</strong>是最重要的方面。实时渲染的开销是很大的，类似于<strong>Lambertian</strong>和<strong>BlinnPhong</strong>这样的光照模型技术，也仅仅是在模拟现实和性能开销中的折中方案。拥有了更加强劲的<strong>GPU(graphics processing unit)</strong>后，我们就可以编写更加精细的光照模型和渲染引擎，目的就是为了模拟光的真实行为。简单概括前面的来说，这就是PBR后面的哲学。正如它的名字所表达的那样， 它是尽可能的去接近真实的物理，来处理每一个不同材质，让他们看起来都不一样。不仅如此，PBR这个术语被广泛的用于市场营销，它更像是<strong>艺术级的渲染(state-of-the-art rendering)</strong>，而不是一个简单的技术。Unity5通过引入两个重要的改变，实现了PBR。首先是一个全新的光照模型(叫<strong>Standard</strong>)。表面着色器允许开发人员指定材质的物理属性，但是他们却没有对它们应用任何的物理原理限制。PBR用新的光照模型来弥补了这个差距，应用了一些物理原理，比如<strong>能量守恒(energy conservation)</strong>[一个物体反射的光线不可能多于接收的光线]，<strong>微表面散射(microsurface scattering)</strong> [粗糙表面比光滑表面的反射更没有规律]，<strong>菲涅尔反射(Fresnel reflectance)</strong>[镜面反射出现在掠射角内]，和<strong>表面阻塞(surface occlusion)</strong>[一些角落的暗部和一些几何体很难照亮]。所有说的这方面，还有一些其他的，都被用来计算标准光照模型。第二方面让PBR开起来如此真实技术叫<strong>全局光照(Global Illumination [GI])</strong>，它是对基于物理原理的光线传输的模拟。也就是说，如果这些物体是独立的实体，那么它们不会被绘制[不会反光只吸收光的的物体，这种绝对黑体是看不见的]。它们会影响最终的渲染效果，因为光线在碰到其他物体前首先会从它们身上反射。虽然在着色器中不会自动提及这方面，但是对于了解渲染引擎是如何工作来说是很重要的部分。然而令人难过的是，实时的精确模拟光线在物体表面到底是如何反弹，这已经超出了现代GPU的能力范围。Unity5做了一些很聪明的优化，即保持了视觉质量有没有牺牲性能。然而大部分的一些进阶技术(比如反射) 需要用户的输入。上面说的这些方面都会在本章介绍。 不过希望各位留意的是，即使是PBR或者GI这些技术也不能保证你的游戏可以获得照片级的画质。要获得照片级的画面是一项很有挑战性的工作，跟每一门艺术一样，需要非常专业和杰出的技巧。</p></ul><hr /><p><span id="UTMS"></span></p><h2 id="理解金属质感的设置">理解金属质感的设置</h2><p>Unity5提供了两种不同类型的PBR着色器； 它们指的是材质的<strong>检查器面板(Inspector)</strong>中的下拉列表中的<strong>Standard</strong>着色器和<strong>Standard (Specular setup)</strong>着色器。两者的主要区别在于前者为我们暴露了<strong>Metallic</strong>这个属性，而后者没有<strong>Metallic</strong>，但暴露了<strong>Specular</strong>这个属性。metallic 属性和specular 属性代表了初始化PBR材质不同方式。推动PBR的概念之一是提供给开发人员和艺术家一种有目的性的，基于物理相关的一些属性，让他们可以调整和把玩它们。 有些材质的属性更容易用来表示它们的质金属质感强度指标，而其他的另一些属性则直接于定义了光是如何反射的，也很重要。如果你过去使用过Unity4，那么对于<strong>Standard (Specular setup)</strong>着色器应该看起来更熟悉。这个知识点会教你如何有效的使用<strong>金属质感设置(metallic setup)</strong>。有个重点需要各位注意，金属质感的工作流不仅仅用于金属材质；它是根据表面的金属质感或者非金属质感来定义材质的视觉效果的一种方式。尽管呈现的是两种不同的类型的着色器，但这<strong>金属(Metallic )</strong>和<strong>镜面(Specular)</strong>这两种方案通常来说是相等的表示。 就像Unity文档中所展示的：<a href="http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html">http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html</a>，这两种设置都可以创建同样的材质(如下图所示)：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram47.png" /></div><hr /><ul><li><p><strong>始前准备</strong><span id="UTMS_getting_ready"></span></p><p>在这个知识点中我们将用Unity5提供的标准着色器，所以我们没有必要重新创建一个。我们通过下面的步骤来开始学习这个知识点：</p><ol><li>创建一个新的材质球。<li>在这个材质球的<strong>检查器(Inspector)</strong>面板，确保<strong>Shader</strong>这个下拉菜单中选择的是<strong>Standard</strong>。</ol><p>同时你需要一个带有纹理的3D模型。</p></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="UTMS_how_to_do_it"></span></p><p>在标准着色器中有两个主要的纹理需要配置：<strong>Albedo</strong>和<strong>Metallic</strong>。为了有效地使用金属化工作流，我们需要正确的初始化这些映射：</p><ol><li><strong>Albedo</strong>映射应该用3D模型的<strong>unlit(不受光照影响)</strong>纹理初始化。<li>创建<strong>Metallic</strong>映射之前，先复制一份文件用留给<strong>Albedo</strong>映射。你可以在<strong>项目(Project)</strong>面板中中选择要复制的贴图，然后通过快捷键<strong><em>Ctrl + D</em></strong>复制。<li>用白色 (#000000)给表示纯金属的材质的贴图区域上色。而其他要用的的颜色都用黑色(#000000)。灰色的着色应该用于表示满是灰尘的，风化的和磨损的金属表面，还有生锈表面，有刮擦的绘画等等。事实上，Unity仅仅使用了红颜色(R)通道来保存金属质感的值；而绿颜色通道(G)和蓝颜色通道(B)则被忽略了。<li>用图片的的alpha通道来提供材质的<strong>光滑度(Smoothness)</strong>信息。<li>把<strong>金属质感(Metallic)</strong>贴图关联到材质球中。<strong>金属质感(Metallic)</strong>和<strong>光滑度(Smoothness)</strong>的滑动条都会消失，因为这两个属性现在由贴图控制了。</ol></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="UTMS_how_it_works"></span></p><p>旧着色器中的光照模型条件让艺术家们很难创造出贴近现实视觉效果。之所以会这样，是因为旧的表面着色器中所有的属性间没有关联。通过介绍金属质感的工作流，Unity5将强制对游戏对象的表现将添加更多系统参数，这样的话艺术家们就能更易创建合理的材质。</p><p>金属是电的良导体；而光是电磁波的一种形式，也就是说相比于不良导体(经常被称为<strong>绝缘体(insulators)</strong>)，几乎所的金属都有相似的行为表现。导体的反射率很高，能反射大部分的光子(70-100%)。然后剩余没有被反射的光就被吸收了，不是漫反射出来，也就是说导体的漫反射元素很黑[其实我觉得翻译成很低也能说的通]。相反的是，绝缘体反射率很低(%4)而剩余的光在表面被散射掉了，所以漫反射效果明显。</p><p>在标准着色器中，纯金属材质拥有较黑的漫反射元素并且它的镜面反射的颜色由<strong>Albedo</strong>贴图来定义。相反的，对于纯粹的非金属材料来说，<strong>Albedo</strong>贴图定义的是它们的漫反射元素； 而它们的镜面高光颜色其实是由射进来的光颜色决定的遵守这些规则在金属工作流中可以把<strong>albedo</strong>和<strong>specular</strong>结合进<strong>Albedo</strong>贴图中去，实行精确的物理行为。在牺牲材质视觉效果控制的前提下，这能让我们节省更多的空间，而且极大的提升运行速度。</p></ul><hr /><ul><li><p><strong>额外内容</strong><span id="UTMS_see_also"></span></p><p>想获得更多关于金属质感的设置的信息，你可以参考下面链接的信息：</p><p><strong>校准图表(Calibration chart)</strong>：如何校准一个金属质感的材质球</p><p>(<a href="http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png">http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png</a>)</p><p><strong>材质图表(Material chart)</strong>: 如何为一些常用的材质初始化标准着色器的参数</p><p>(<a href="http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html">http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html</a>)</p><p><strong>Quixel MEGASCANS</strong>: 一个巨量的材质素材仓库[网站]，还包括纹理和PBR的参数设置[网站已经变了，我纠正一下]</p><p>(<a href="https://quixel.com/megascans/home/">https://quixel.com/megascans/home/</a>)</p><p><strong>PBR纹理的转换</strong>：传统的着色器如何转换成PBR着色器</p><p>(<a href="http://www.marmoset.co/toolbag/learn/pbr-conversion">http://www.marmoset.co/toolbag/learn/pbr-conversion</a>)</p><p><strong>Substance Designer</strong>：一个基于节点的跟PBR一起工作的额软件</p><p>(<a href="https://www.allegorithmic.com/products/substance-designer">https://www.allegorithmic.com/products/substance-designer</a>)</p><p><strong>基于物理原理渲染的理论</strong>：一个关于PBR的完全教程[源网址已经变了，帮大家重新找到了]</p><p>(<a href="https://academy.substance3d.com/courses/the-pbr-guide-part-1-zh">https://academy.substance3d.com/courses/the-pbr-guide-part-1-zh</a>)</p></ul><hr /><p><span id="ATTOPBR"></span></p><h2 id="向pbr中添加透明度">向PBR中添加透明度</h2><p>透明度是游戏中很重要的一个方面，标准着色器支持三种不同的实现方式。 如果你想让你的材质获得很逼真的透明或者半透明属性，这个知识点非常有用。玻璃，玻璃瓶子，玻璃窗和各种结晶体都很适合PBR透明着色器。这是因为你依然可以获得PBR带来的包含透明和半透明的效果的逼真效果。 如果你想让UI或者像素艺术这样的不同的东西也具有半透明效果，这里由更加高效的可选方法，就是在<a href="https://linkliu.github.io/game-tech-post/posts/%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/">第二章</a> <strong>表面着色器和纹理贴图</strong> 这一章节中，<strong><a href="https://linkliu.github.io/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B8%A6%E9%80%8F%E6%98%8E%E5%BA%A6%E7%9A%84%E6%9D%90%E8%B4%A8/">创建一个带透明度的材质</a></strong> 这个知识点。</p><p><strong>注意</strong></p><p>为了能获得一个有透明度的标准材质，仅仅是修改它的<strong>Albedo</strong>颜色属性的alpha通道是不够的。除非你把<strong>Rendering Mode</strong>设置成transparent，否则你的材质是不会产生透明度的。</p><hr /><ul><li><p><strong>始前准备</strong><span id="ATTOPBR_getting_ready"></span></p><p>这个知识点将会使用<strong>标准着色器(Standard Shader)</strong>，所以我们没有必要创建新的着色器了：</p><ol><li>创建一个新的材质球<li>在材质球的<strong>检查器(Inspector)</strong>面板确保<strong>Shader</strong>这个属性设置为了<strong>Standard</strong>或者<strong>Standard (Specular setup)</strong>。<li>然后把这个新创建好的材质球应邀到你想要实现透明度的3D模型上。</ol></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="ATTOPBR_how_to_do_it"></span></p><p>标准着色器提供了三种不同类型的透明度。尽管非常的相似，但是它们仍然又细微的差别，并且适用的情形也是不同的。</p><p><strong>半透明材质</strong></p><p>像干净的塑料，晶体和玻璃这些材料是半透明的。 这就意味着它们都需要PBR这种逼真的效果(比如镜面高光，菲涅尔折射和反射)而且允许几何体后面也能被看见的话。如果这是你想要的效果，就按照下面的步骤走：</p><ol><li>在材质球的<strong>检查器(Inspector)</strong>面板，把<strong>Rendering Mode</strong>这个属性设置为<strong>Transparent</strong>。<li>透明度的数值由<strong>Albedo</strong>颜色或者<strong>Albedo</strong>贴图(如果有)的alpha通道来决定。</ol><p>下图展示的是Unity5校准场景中四种高度抛光过的塑料球。从左到右，它们的透明度逐渐增高。最后的一个球是完全透明的，但依然保有PBR中添加的效果：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram48.png" /></div><center> <b>Transparent</b>这个渲染模式非常适合窗户，瓶子，宝石和头戴式耳机</center><p><strong>注意</strong></p><p>你需要注意的是大部分的透明材质不会投射阴影。 除此之外，材质的<strong>Metallic</strong>和<strong>Smoothness</strong>也会影响到透明效果。镜子似的表面可以通过把alpha设置为0获得，但是如果它反射所有入射光的话，它就不会表现出透明效果。</p><p><strong>渐隐的游戏对象</strong></p><p>有时候，你想用渐隐效果让一个游戏对象完全消失。在这个例子中，镜面反射，菲涅尔折射 和反射等效果也会消失。当一个渐隐的游戏对象完全透明，它应该是看不见的。为了完成这些，按照下面的步骤操作：</p><ol><li>在材质的<strong>检查器(Inspector)</strong>面板，把<strong>Rendering Mode</strong>设置为<strong>Fade</strong>。<li>如前面一样，用<strong>Albedo</strong>的颜色或者贴图的alpha通道来决定最终的透明度。</ol><p>下图展示了一个渐隐的球体。从图中明显可以看出PBR效果也随着渐隐效果逐渐消失。正如你从下面图见到的那样，往右最后的那个球近乎消失不见了：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram49.png" /></div><p>这个渲染模式最适合<strong>非真实(non-realistic)</strong>物体，比如全息投影，镭射光线，人造光线，幽灵和粒子等效果。</p><p><strong>有洞的固态几何体</strong></p><p>在游戏中遇到的大多数材质都是不透明的，也就是说光没有办法穿透它们。与此同时，很多物体还有非常复杂的几何面(还有平面)。如果用3D</p><p>模型来制作叶子和草未免右点太复杂了。一个更加高效的方式使用<strong>quad(其实是一个矩形)</strong>加一个叶子的纹理来制作。但是叶子本身是不透明的，那剩下的那张纹理就完全是透明的。 如果你想做这种效果，就按照下面的步骤操作：</p><ol><li>再材质的<strong>检查器(Inspector)</strong>面板，把<strong>Rendering Mode</strong>设置成<strong>Cutout</strong>。<li>然后使用<strong>Alpha Cutoff</strong>滑动条来调整裁剪阈值。在<strong>Albedo</strong>贴图中所有alpha值等于或者小于<strong>Alpha Cutoff</strong>值的像素点都会被隐藏。</ol><p>下图截取至Unity官方的PBR教程(<a href="https://www.youtube.com/watch?v=fD_ho_ofY6A">https://www.youtube.com/watch?v=fD_ho_ofY6A</a>)[需要用梯子]，向你演示了<strong>Cutout</strong>渲染模式效果如何在几何体上打一个孔洞：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram50.png" /></div><p>值得注意的是<strong>Cutout</strong>并不允许几何体背面被看见。在前面的示例中，你不能看到球体的内部体积部分。如果你需要这样的一个效果，你需要创建自己的着色器并且确定几何体的背部不会被踢除。</p></ul><hr /><ul><li><p><strong>额外内容</strong><span id="ATTOPBR_see_also"></span></p><p>这个知识的演示，使用了Unity商城中的<strong>ShaderCalibration Scene</strong>免费资源，地址如下[已经失效了]：</p><p><a href="https://www.assetstore.unity3d.com/en/#!/content/25422">https://www.assetstore.unity3d.com/en/#!/content/25422</a>。</p><p>更多关于<strong>albedo</strong>和<strong>transparency</strong>的信息，可以通过下面的链接查询：</p><p><a href="http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html">http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html</a>。</p></ul><hr /><p><span id="CMARS"></span></p><h2 id="创建镜子和反射面">创建镜子和反射面</h2><p>当我们从一定的角度看高光材质物体时，物体会反射光。然而可惜的是，即使是最精确的光照模型之一：<strong>菲涅尔反射Fresnel reflection</strong>，也不能完全准确的反射来自周围物体的光。前一个章节验证过的光照模型只考虑了一些光源，但是却忽略了来自其他表面的反射光。很显然，用目前我们学的关于着色的知识，来创建一面镜子是不可能的。但是<strong>全局光照Global illumination</strong>技术提供了这种可能性，这需要提供包含了周围光照信息的PBR着色器。 这就要求物体不仅需要有高光部分，还需要有依赖周围其他物体的真实的反射部分。实时的反射非常消耗性能并且需要一些自定义的设置和调整才能工作，它们可以用来创建类似镜面的效果，就如下图所示：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram51.png" /></div><hr /><ul><li><p><strong>始前准备</strong><span id="CMARS_getting_ready"></span></p><p>这个知识点中不会涉及新的着色器。恰恰相反，大部分的工作都可以直接在编辑器上完成。就像下面的步骤展示的那样：</p><ol><li>创建一个新场景<li>然后在场景中创建一个<strong>quad</strong>，这个quad会用来作为镜子。<li>创建一个新的材质并且把它跟这个镜子关联起来。<li>把这个quad放在另一个游戏对象前面。<li>在Unity菜单中通过<strong>GameObject | Light | Reflection Probe</strong>的步骤创建一个<strong>反射探针reflection probe</strong>并且把它放在quad的前面。</ol></ul><hr /><ul><li><p><strong>操作步骤</strong><span id="CMARS_how_to_do_it"></span></p><p>如果正确的按照前面的步骤操作，那么在你的场景中间会有一个quad，靠近它还有一个反射探针。为了让它出现在镜子中，还需要做西面的这些改变：</p><ol><li>把材质的着色器类型改成<strong>Standard</strong>并且把<strong>Rendering Mode</strong>设置成<strong>Opaque</strong>。【这里的属性英文不翻译把，因为Unity大部分人都是用的英文，我担心找不到】<li>把<strong>Metallic</strong>和<strong>Smoothness</strong>这两个的属性设置为1。你可以看到材质会很清晰的反射天空盒。<li>选择反射探针并且修改<strong>Size</strong>和<strong>Probe Origin</strong>直到它刚好在quad的前面，并且让探针包含你想反射的物体。<li>最后把<strong>Type</strong>改成<strong>Realtime</strong>。确定<strong>Culling Mask</strong>设置的是<strong>Everything</strong>。</ol><p>这样的话，你的反射探针就设置好了，看起来就跟下图一样：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram52.png" /></div><p>如果你的探针是用来做真正的镜子，那么你应该勾选<strong>Box Projection</strong>这个选项。如果你是用来做一些类似于亮晶晶的小金属碎片或者玻璃桌子，那么你就不应该勾选这个选项。</p></ul><hr /><ul><li><p><strong>原理介绍</strong><span id="CMARS_how_it_works"></span></p><p>当着色器想要周围环境信息的时候，它自己提供了一个叫做<strong>cube maps</strong>的数据结构。它在<a href="https://linkliu.github.io/game-tech-post/posts/第一章.创建你的第一个着色器/">第一章</a>,<strong><em>创建你的第一个着色器</em></strong> 简短的提及过，跟<strong>Color</strong>，<strong>2D</strong>，<strong>Float</strong>和<strong>Vector</strong>这些结构一样，都是Cg语言中的一种数据结构。笼统一点来说，<strong>cube maps</strong>就是2D纹理的3D数据结构。它们表示从中心点看过来的360度的世界视角。 Unity5可以通过特殊的投影预览<strong>cube maps</strong>，如下图所示：</p><div align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://linkliu.github.io/game-tech-post/assets/img/shader_book/diagram53.png" /></div><p>当cube maps关联到一个摄像机时，它们会被<strong>天空盒skyboxes</strong>引用，因为它们此时时被用于反射天空的一种方式。它们能用于反射不在实际场景中的几何体，比如星云，云朵，星星等等。</p><p>之所以会把它们叫做<strong>立方体贴图(cube maps)</strong>原因跟它们的创建方式有关：一个立方体贴图是由6张不同的纹理组成的，立方的每个面都有一张纹理。你可以手动的创建一个立方体贴图然后把它放到一个<strong>反射探针(reflection probe)</strong>上。你可以把反射探针想象成一个拥有6个摄像机，拥有周围环境360度贴图的几何体。 这也解释了为什么探针的性能消耗会这么高。 在我们的场景中创建一个反射探针，这样允许Unity知道那些游戏对象再镜子的周围。如果你需要更多的反射面，那你可以添加多个探针。探针此时可以工作了，你无需再做进一步的操作。<strong>标准着色器(Standard Shaders)</strong>会自动使用它们。</p><p>需要注意的是当它们被设置成<strong>实时(Realtime)</strong>的时候，它们会在每一帧的开始渲染立方体贴图。这里有一个技巧可以让这个过程更快；如果你知道你想反射的几何体的哪个部分是不会移动的，你可以对反射进行烘焙。这意味着Unity可以在游戏开始前就将反射预先计算好，可以允许更精确(计算量更大)的计算。 为了做这个操作，那么你的反射探针需要设置成<strong>烘培(Baked)</strong>，于此同时游戏对象也要标记为<strong>静态(Static)</strong>才行。静态的游戏对象没法移动和改变，因此它们特别适合地形，建筑和道具。只要静态游戏对象发生变化，Unity都会为烘焙的反射探针重新生成立方体贴图。这可能要花费几分钟到几个小时。</p><p>为了让你的游戏更加的贴近现实，有时候你需要把<strong>实时(Realtime)</strong>和<strong>烘培(Baked)</strong>这两种探针综合来使用。 烘培过的探针能获得高质量的环境反射，然而实时探针可以用于移动的游戏对象比如汽车或者镜子。下一个知识点 <strong><em>烘培场景中的光</em></strong> 将会解释如何进行光的烘培的具体细节。</p></ul><hr /><ul><li><p><strong>额外内容</strong><span id="CMARS_see_also"></span></p><p>如果你像学习更多关于反射探针的内容，你应该通过下面的链接学习： <a href="https://docs.unity3d.com/Manual/class-ReflectionProbe.html">https://docs.unity3d.com/Manual/class-ReflectionProbe.html</a></p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/game-tech-post/categories/shader/'>shader</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/game-tech-post/tags/u3d/" class="post-tag no-text-decoration" >U3D</a> <a href="/game-tech-post/tags/shader/" class="post-tag no-text-decoration" >Shader</a> <a href="/game-tech-post/tags/cookbook/" class="post-tag no-text-decoration" >Cookbook</a> <a href="/game-tech-post/tags/%E4%B8%AD%E6%96%87%E7%89%88/" class="post-tag no-text-decoration" >中文版</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Unity 5.x shaders and effects cookbook中文版翻译（第二版） - Game-Tech-Post&url=https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Unity 5.x shaders and effects cookbook中文版翻译（第二版） - Game-Tech-Post&u=https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Unity 5.x shaders and effects cookbook中文版翻译（第二版） - Game-Tech-Post&url=https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/game-tech-post/posts/%E7%83%98%E5%9F%B9%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%85%89/">烘培场景中的光</a><li><a href="/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/">Unity 5.x shaders and effects cookbook中文版翻译（第二版）</a><li><a href="/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E9%95%9C%E5%AD%90%E5%92%8C%E5%8F%8D%E5%B0%84%E9%9D%A2/">创建镜子和反射面</a><li><a href="/game-tech-post/posts/%E5%A6%82%E4%BD%95%E6%8A%8AUnity-4%E7%9A%84%E6%97%A7%E7%9D%80%E8%89%B2%E5%99%A8%E8%BF%81%E7%A7%BB%E8%87%B3Unity-5/">如何把unity 4的旧着色器迁移至unity 5</a><li><a href="/game-tech-post/posts/%E7%BB%99%E7%9D%80%E8%89%B2%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/">给着色器添加属性</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/game-tech-post/tags/u3d/">U3D</a> <a class="post-tag" href="/game-tech-post/tags/cookbook/">Cookbook</a> <a class="post-tag" href="/game-tech-post/tags/shader/">Shader</a> <a class="post-tag" href="/game-tech-post/tags/%E4%B8%AD%E6%96%87%E7%89%88/">中文版</a> <a class="post-tag" href="/game-tech-post/tags/hierarchy/">Hierarchy</a> <a class="post-tag" href="/game-tech-post/tags/layabox/">LayaBox</a> <a class="post-tag" href="/game-tech-post/tags/navmesh/">NavMesh</a> <a class="post-tag" href="/game-tech-post/tags/unity/">Unity</a> <a class="post-tag" href="/game-tech-post/tags/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/">右键菜单</a> <a class="post-tag" href="/game-tech-post/tags/%E7%BC%96%E8%BE%91%E5%99%A8/">编辑器</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAToon%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8/"><div class="card-body"> <span class="timeago small" > Feb 23 <i class="unloaded">2021-02-23T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>创建一个toon风格的着色器</h3><div class="text-muted small"><p> 创建一个Toon风格的着色器 Toon着色器(toon shading)是游戏中最常使用的效果之一，也被称作(AKA)cel shading(cel是celluloid的缩写[中文也叫 赛璐珞])。它是一种非真实渲染技术，可以让3D模型呈现一种平面效果。许多游戏中用这种着色器把3D的物体渲染成一种手绘物体的效果。下图中你能看到这两者的区别，右边的是标准着色器，左边的是Toon着色器： 如...</p></div></div></a></div><div class="card"> <a href="/game-tech-post/posts/%E5%88%9B%E5%BB%BA-BlinnPhong-%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E7%9D%80%E8%89%B2%E5%99%A8/"><div class="card-body"> <span class="timeago small" > Feb 25 <i class="unloaded">2021-02-25T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>创建 blinnphong 类型的高光反射着色器</h3><div class="text-muted small"><p> 创建 BlinnPhong 类型的高光反射着色器 Blinn是另一种计算和模拟高光的更有效的方法。它只要视角方向和光线方向向量的中间向量就可以计算出来。这个高光是Jim Blinn带入到Cg世界中的。 他发现比起计算反射向量来，只要中间向量的效率更好。它减少了代码量和处理时间。 如果你在UnityCG.cginc文件中查看了Unity内建的BlinnPhong光照模型的话，它也是用了中间向...</p></div></div></a></div><div class="card"> <a href="/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAPhong%E9%95%9C%E9%9D%A2%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E7%9D%80%E8%89%B2%E5%99%A8/"><div class="card-body"> <span class="timeago small" > Feb 25 <i class="unloaded">2021-02-25T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>创建一个phong镜面类型的高光反射着色器</h3><div class="text-muted small"><p> 创建一个Phong类型类型的高光反射着色器 一个物体表面的高光，可以简单的理解为它表面的亮度。这种类型的着色器常用于视野特效(view-dependent effects)。这是因为 为了在着色器中获得贴近现实的高光效果，你需要考虑到摄像机和人的朝向因素。而Phong高光效果是最基础和性能较好的一种着色器效果。它根据人的朝向和光的反射方向，通过计算获得一个有方向的反射。 在应用程序中，这种...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E9%95%9C%E5%AD%90%E5%92%8C%E5%8F%8D%E5%B0%84%E9%9D%A2/" class="btn btn-outline-primary" prompt="Older"><p>创建镜子和反射面</p></a> <a href="/game-tech-post/posts/%E7%83%98%E5%9F%B9%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%85%89/" class="btn btn-outline-primary" prompt="Newer"><p>烘培场景中的光</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">Link Liu</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/game-tech-post/tags/u3d/">U3D</a> <a class="post-tag" href="/game-tech-post/tags/cookbook/">Cookbook</a> <a class="post-tag" href="/game-tech-post/tags/shader/">Shader</a> <a class="post-tag" href="/game-tech-post/tags/%E4%B8%AD%E6%96%87%E7%89%88/">中文版</a> <a class="post-tag" href="/game-tech-post/tags/hierarchy/">Hierarchy</a> <a class="post-tag" href="/game-tech-post/tags/layabox/">LayaBox</a> <a class="post-tag" href="/game-tech-post/tags/navmesh/">NavMesh</a> <a class="post-tag" href="/game-tech-post/tags/unity/">Unity</a> <a class="post-tag" href="/game-tech-post/tags/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/">右键菜单</a> <a class="post-tag" href="/game-tech-post/tags/%E7%BC%96%E8%BE%91%E5%99%A8/">编辑器</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/game-tech-post/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://linkliu.github.io/game-tech-post{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
