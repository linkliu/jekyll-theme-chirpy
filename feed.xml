<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://linkliu.github.io/game-tech-post/game-tech-post/</id><title>Game-Tech-Post</title><subtitle>游戏技术资料，游戏技术文档，Unity，LayaBox，ShaderBook，shaderLab</subtitle> <updated>2021-06-18T23:13:11+08:00</updated> <author> <name>Link Liu</name> <uri>https://linkliu.github.io/game-tech-post/game-tech-post/</uri> </author><link rel="self" type="application/atom+xml" href="https://linkliu.github.io/game-tech-post/game-tech-post/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://linkliu.github.io/game-tech-post/game-tech-post/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 Link Liu </rights> <icon>/game-tech-post/assets/img/favicons/favicon.ico</icon> <logo>/game-tech-post/assets/img/favicons/favicon-96x96.png</logo> <entry><title>在unity的hierarchy面板上添加鼠标右键菜单</title><link href="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%9C%A8Unity%E7%9A%84Hierarchy%E9%9D%A2%E6%9D%BF%E4%B8%8A%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/" rel="alternate" type="text/html" title="在unity的hierarchy面板上添加鼠标右键菜单" /><published>2021-05-25T00:00:00+08:00</published> <updated>2021-05-25T00:00:00+08:00</updated> <id>https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%9C%A8Unity%E7%9A%84Hierarchy%E9%9D%A2%E6%9D%BF%E4%B8%8A%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</id> <content src="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%9C%A8Unity%E7%9A%84Hierarchy%E9%9D%A2%E6%9D%BF%E4%B8%8A%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/" /> <author> <name>Link Liu</name> </author> <category term="UnityEditor" /> <summary> 在Unity的Hierarchy面板上添加右键菜单 这里添加的是复制一个模型的节点信息的功能，从子节点自身开始复制，一直到模型的父节点终止。因为有时候模型的子节点比较多，一个一个的去点开查找比较麻烦，或者想查看子节点的路径对不对。记得priority要写。 代码如下： public static class EditorTool { [MenuItem("GameObject/EditorTool/CopyPath", priority = 0)] static string CopyPath() { if (Selection.gameObjects.Length == 1) { GameObject selectObj = Selection.gameObjects[0];... </summary> </entry> <entry><title>烘培场景中的光</title><link href="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E7%83%98%E5%9F%B9%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%85%89/" rel="alternate" type="text/html" title="烘培场景中的光" /><published>2021-05-21T00:00:00+08:00</published> <updated>2021-06-18T22:58:49+08:00</updated> <id>https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E7%83%98%E5%9F%B9%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%85%89/</id> <content src="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E7%83%98%E5%9F%B9%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%85%89/" /> <author> <name>Link Liu</name> </author> <category term="shader" /> <summary> 烘培场景中的光 渲染光照的过程是非常消耗新能的。即使是目前最好的[state-of-the-art]1GPU，要准确的计算光的运动(light transport) [是指光在物体表面之间反射]也要花好些小时。 为了在游戏中让这个过程可行，光的实时渲染是必须要有的。如今的游戏引擎会在画面和效率上采取一个合理的折中方案；大部分的计算都在一个叫光烘焙(light baking)过程中事先计算好了。这一个知识点将会讲解光烘焙是如何工作的并且你该如何充分的利用它。 始前准备 光的烘焙需要你先准备一个场景。里面要有一些几何体，当然光也一定要有。这个知识点我们会基于Unity的标准特性，所以没有必要创建新的着色器或者材质。为了更好的控制这个过程，你可能需要访问Lighting窗口。如果你没有看见这个窗口，可以通过菜单 Window | Lighting打开，... </summary> </entry> <entry><title>Unity 5.x shaders and effects cookbook中文版翻译（第二版）</title><link href="https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/" rel="alternate" type="text/html" title="Unity 5.x shaders and effects cookbook中文版翻译（第二版）" /><published>2021-05-21T00:00:00+08:00</published> <updated>2021-05-28T15:24:08+08:00</updated> <id>https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/</id> <content src="https://linkliu.github.io/game-tech-post/game-tech-post/posts/Unity-5.x-Shaders-and-Effects-Cookbook%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91-%E7%AC%AC%E4%BA%8C%E7%89%88/" /> <author> <name>Link Liu</name> </author> <category term="shader" /> <summary> ​ 我打算试着翻译这本技术书，目的又两个，1.希望自己能帮助英文不太好的朋友，2.希望自己也学到这些知识，顺便帮助自己提升英语水平。我英语水平不是很好，接下来如果有什么错误的地方，有看到的朋友还请帮忙纠正。我不会web前端技术，我想试着学学markdown语法，尽量让页面好看些但是最重要的还是内容。 Unity 5.x Shaders and Effects Cookbook中文版（第二版） 目录表 鸣谢 关于作者 www.PacktPub.com 电子书, 优惠, 还有其他 为什么需要订阅? 前言 这本书包含哪些内容 学习的过程中你需要准备的 本书的适合人群 内容结构 始前准备 ... </summary> </entry> <entry><title>创建镜子和反射面</title><link href="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E9%95%9C%E5%AD%90%E5%92%8C%E5%8F%8D%E5%B0%84%E9%9D%A2/" rel="alternate" type="text/html" title="创建镜子和反射面" /><published>2021-05-17T00:00:00+08:00</published> <updated>2021-05-28T09:14:18+08:00</updated> <id>https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E9%95%9C%E5%AD%90%E5%92%8C%E5%8F%8D%E5%B0%84%E9%9D%A2/</id> <content src="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%88%9B%E5%BB%BA%E9%95%9C%E5%AD%90%E5%92%8C%E5%8F%8D%E5%B0%84%E9%9D%A2/" /> <author> <name>Link Liu</name> </author> <category term="shader" /> <summary> 创建镜子和反射面 当我们从一定的角度看高光材质物体时，物体会反射光。然而可惜的是，即使是最精确的光照模型之一：菲涅尔反射Fresnel reflection，也不能完全准确的反射来自周围物体的光。前一个章节验证过的光照模型只考虑了一些光源，但是却忽略了来自其他表面的反射光。很显然，用目前我们学的关于着色的知识，来创建一面镜子是不可能的。但是全局光照Global illumination技术提供了这种可能性，这需要提供包含了周围光照信息的PBR着色器。 这就要求物体不仅需要有高光部分，还需要有依赖周围其他物体的真实的反射部分。实时的反射非常消耗性能并且需要一些自定义的设置和调整才能工作，它们可以用来创建类似镜面的效果，就如下图所示： 始前准备 这个知识点中不会涉及新的着色器。恰恰相反，大部分的工作都可以直接在编辑器上完成。就像下面的步骤展示的那样： ... </summary> </entry> <entry><title>向pbr中添加透明度</title><link href="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%90%91PBR%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%80%8F%E6%98%8E%E5%BA%A6/" rel="alternate" type="text/html" title="向pbr中添加透明度" /><published>2021-03-15T00:00:00+08:00</published> <updated>2021-05-17T14:02:58+08:00</updated> <id>https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%90%91PBR%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%80%8F%E6%98%8E%E5%BA%A6/</id> <content src="https://linkliu.github.io/game-tech-post/game-tech-post/posts/%E5%90%91PBR%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%80%8F%E6%98%8E%E5%BA%A6/" /> <author> <name>Link Liu</name> </author> <category term="shader" /> <summary> 向PBR中添加透明度 透明度是游戏中很重要的一个方面，标准着色器支持三种不同的实现方式。 如果你想让你的材质获得很逼真的透明或者半透明属性，这个知识点非常有用。玻璃，玻璃瓶子，玻璃窗和各种结晶体都很适合PBR透明着色器。这是因为你依然可以获得PBR带来的包含透明和半透明的效果的逼真效果。 如果你想让UI或者像素艺术这样的不同的东西也具有半透明效果，这里由更加高效的可选方法，就是在第二章 表面着色器和纹理贴图 这一章节中，创建一个带透明度的材质 这个知识点。 注意 为了能获得一个有透明度的标准材质，仅仅是修改它的Albedo颜色属性的alpha通道是不够的。除非你把Rendering Mode设置成transparent，否则你的材质是不会产生透明度的。 始前准备 这个知识点将会使用标准着色器(Standard Shader)，所以我们没有必要创建... </summary> </entry> </feed>
